
module axis_master_fifo#(T, int DEPTH, int MAY_PUSH_LATENCY) {
    input bool aresetn'0

    input bool tready'0
    output bool tvalid'0
    output bool[sizeof#(T)] tdata'0

    /// Basically the same as a FWFT XPM FIFO, just that we can't yet instantiate that one without an extra SV file. (#131)
    state T[DEPTH] memory
    state int#(FROM: 0, TO: DEPTH) wr_addr
    state int#(FROM: 0, TO: DEPTH) rd_addr
    
    bool do_read = !tvalid | tready & tvalid

    gen int NUM_PIPELINE_STAGES
    if DEPTH <= 64 {
        NUM_PIPELINE_STAGES = 1
    } else {
        NUM_PIPELINE_STAGES = 2
    }
    state T[NUM_PIPELINE_STAGES] memory_read_pipeline_stages
    state bool[NUM_PIPELINE_STAGES] memory_read_pipeline_stages_valids
    when do_read {
        for int i in 1..NUM_PIPELINE_STAGES {
            memory_read_pipeline_stages[i] = memory_read_pipeline_stages[i-1]
            memory_read_pipeline_stages_valids[i] = memory_read_pipeline_stages_valids[i-1]
        }
        bool read_from_mem_is_valid = rd_addr != wr_addr
        memory_read_pipeline_stages_valids[0] = read_from_mem_is_valid
        when read_from_mem_is_valid {
            memory_read_pipeline_stages[0] = memory[rd_addr]
            rd_addr = (rd_addr + 1) % DEPTH
        }
    }

    tdata = transmute_to_bits(memory_read_pipeline_stages[NUM_PIPELINE_STAGES - 1])
    tvalid = memory_read_pipeline_stages_valids[NUM_PIPELINE_STAGES - 1]

    int free_space = (rd_addr - wr_addr - 1) % DEPTH

    output bool may_push'-MAY_PUSH_LATENCY
    may_push = LatencyOffset#(OFFSET: -MAY_PUSH_LATENCY)(free_space >= MAY_PUSH_LATENCY)
    action push'0: T data'0 {
        memory[wr_addr] = data
        wr_addr = (wr_addr + 1) % DEPTH
    }

    when !aresetn {
        wr_addr = 0
        rd_addr = 0

        for int i in 0..NUM_PIPELINE_STAGES {
            memory_read_pipeline_stages_valids[i] = false
        }
    }
}

/// CTRL REGS is 0x000000
/// Input regs start at 0x000010 and increment 0X000008 every time
/// Output regs start at end of input regs
///
/// XRT imposes a 64K (16bit) address range limitation. 
/// See https://docs.amd.com/r/2023.2-English/ug1393-vitis-application-acceleration/Kernel-Interface-Requirements
///
/// It also appears that ADDR_WIDTH must be >= 12, because the address mapping requires blocks of size 4096
module axi_ctrl_slave #(int NUM_INPUT_REGS, int NUM_OUTPUT_REGS, int ADDR_WIDTH, int AXI_WIDTH) {
    domain aclk
    input bool aresetn

    gen int DATA_STARTS_AT_ADDR = 16 // 0x010
    gen int REG_STRIDE = AXI_WIDTH / 8
    gen int CTRL_REG = 0
    gen int FIRST_REG = DATA_STARTS_AT_ADDR / REG_STRIDE
    assert#(C: DATA_STARTS_AT_ADDR % REG_STRIDE == 0)
    gen int ATO = pow2#(E: ADDR_WIDTH)
    assert#(C: ADDR_WIDTH >= 12)
    assert#(C: ADDR_WIDTH <= 16)
    // Max number of regs
    assert#(C: (FIRST_REG + NUM_INPUT_REGS + NUM_OUTPUT_REGS) * REG_STRIDE <= pow2#(E: ADDR_WIDTH))
    gen bool[2] RESP_OKAY = [false, false]
    gen bool[2] RESP_SLVERR = [false, true]

    // AXI signals
    input int#(FROM: 0, TO: ATO) awaddr
    input bool awvalid
    output bool awready = false
    input bool[AXI_WIDTH] wdata
    input bool[AXI_WIDTH / 8] wstrb
    input bool wvalid
    output bool wready = false
    output bool[2] bresp
    output bool bvalid = false
    input bool bready
    input int#(FROM: 0, TO: ATO) araddr
    input bool arvalid
    output bool arready = false
    output bool[AXI_WIDTH] rdata
    output bool[2] rresp
    output bool rvalid = false
    input bool rready


    state bool[32][NUM_OUTPUT_REGS] stored_output_regs
    output state bool[32][NUM_INPUT_REGS] input_regs
    trigger start

    // control register bits
    state bool reg_ctrl_ap_idle
    state bool reg_ctrl_ap_done
    bool reg_ctrl_ap_ready = reg_ctrl_ap_done    // copy ap_done because there's no pausing
    state bool reg_ctrl_ap_start

    // Write transaction
    state int stored_addr
    state bool stored_addr_valid
    state bool[2] last_bresp
    state bool last_werr_valid
    
    awready = !stored_addr_valid & aresetn // Force low on reset
    wready = stored_addr_valid & !last_werr_valid // Already low by reset
    bvalid = last_werr_valid
    bresp = last_bresp

    when awready & awvalid {
        stored_addr_valid = true
        stored_addr = awaddr / REG_STRIDE
    }
    when wready & wvalid {
        stored_addr_valid = false
        last_werr_valid = true

        last_bresp = RESP_SLVERR
        when stored_addr == CTRL_REG {
            when wstrb[0] & wdata[0] {
                reg_ctrl_ap_start = true
                reg_ctrl_ap_idle = false
                start()
            }
            last_bresp = RESP_OKAY
        }
        // Data Write
        when (stored_addr >= FIRST_REG) & (stored_addr < FIRST_REG + NUM_INPUT_REGS) {
            int write_idx = unsafe_int_cast#(FROM: FIRST_REG, TO: FIRST_REG + NUM_INPUT_REGS)(stored_addr) - FIRST_REG
            for int strbi in 0..4 {
                when wstrb[strbi] {
                    input_regs[write_idx][strbi*8 +: 8] = wdata[strbi*8 +: 8]
                }
            }
            last_bresp = RESP_OKAY
        }
    }
    when bready & bvalid {
        last_werr_valid = false
    }

    // Read transaction
    state bool last_rdata_valid
    state bool[32] last_rdata
    rdata = last_rdata
    state bool[2] last_rresp
    rresp = last_rresp

    bool[32][NUM_INPUT_REGS + NUM_OUTPUT_REGS] regs_read_multiplexer
    regs_read_multiplexer[:NUM_INPUT_REGS] = input_regs
    regs_read_multiplexer[NUM_INPUT_REGS:] = stored_output_regs

    arready = !last_rdata_valid & aresetn // Force low on reset
    rvalid = last_rdata_valid // Already low by reset

    when arready & arvalid {
        last_rdata_valid = true
        
        // Control Read
        last_rresp = RESP_SLVERR
        int read_addr = araddr / REG_STRIDE
        when read_addr == CTRL_REG {
            last_rdata[0] = reg_ctrl_ap_start
            last_rdata[1] = reg_ctrl_ap_done
            last_rdata[2] = reg_ctrl_ap_idle
            last_rdata[3] = reg_ctrl_ap_ready
            last_rdata[4:] = Repeat(false)
            when reg_ctrl_ap_done {
                reg_ctrl_ap_idle = true
            }
            reg_ctrl_ap_done = false // clear on read
            last_rresp = RESP_OKAY
        }
        // Data Read
        when (read_addr >= FIRST_REG) & (read_addr < FIRST_REG + NUM_INPUT_REGS + NUM_OUTPUT_REGS) {
            int read_idx = unsafe_int_cast#(FROM: FIRST_REG, TO: FIRST_REG + NUM_INPUT_REGS + NUM_OUTPUT_REGS)(read_addr) - FIRST_REG
            last_rdata = regs_read_multiplexer[read_idx]
            last_rresp = RESP_OKAY
        }
    }
    when rready & rvalid {
        last_rdata_valid = false
    }

    action finish : bool[32][NUM_OUTPUT_REGS] output_regs {
        stored_output_regs = output_regs
        reg_ctrl_ap_done = true
        reg_ctrl_ap_start = false
        reg_ctrl_ap_idle = false
    }

    when !aresetn {
        stored_addr_valid = false
        last_werr_valid = false

        last_rdata_valid = false

        reg_ctrl_ap_idle = true
        reg_ctrl_ap_start = false
        reg_ctrl_ap_done = false

        input_regs = Repeat(Repeat(false))
        stored_output_regs = Repeat(Repeat(false))
    }
}


module axi_memory_reader_tie_off {
    domain aclk
    input bool aresetn'0

    gen int ADDR_WIDTH = 64
    gen int ATO = pow2#(E: ADDR_WIDTH)
    gen int AXI_WIDTH = 32

    // axi mm master
    // read channels - tie off, never ready/valid
    output bool                     arvalid'0
    input  bool                     arready'0
    output int#(FROM: 0, TO: ATO)   araddr'0
    output int#(FROM: 0, TO: 256)   arlen'0
    output bool[2]                  arburst'0
    input  bool                     rvalid'0
    output bool                     rready'0
    input  bool[AXI_WIDTH]          rdata'0
    input  bool                     rlast'0

    // Tie off
    arvalid = false
    araddr = 0
    arlen = 0
    arburst = Repeat(false)
    rready = false
}

module axi_memory_writer_tie_off {
    domain aclk
    input bool aresetn'0

    gen int ADDR_WIDTH = 64
    gen int ATO = pow2#(E: ADDR_WIDTH)
    gen int AXI_WIDTH = 32

    // axi mm master
    // write channels - tie off, never ready/valid
    output bool                     awvalid'0
    input  bool                     awready'0
    output int#(FROM: 0, TO: ATO)   awaddr'0
    output int#(FROM: 0, TO: 256)   awlen'0
    output bool[2]                  awburst'0
    output bool                     wvalid'0
    input  bool                     wready'0
    output bool[AXI_WIDTH]          wdata'0
    output bool[AXI_WIDTH / 8]      wstrb'0
    output bool                     wlast'0
    input  bool                     bvalid'0
    output bool                     bready'0

    // Tie off
    awvalid = false
    awaddr = 0
    awlen = 0
    awburst = Repeat(false)
    wvalid = false
    wdata = Repeat(false)
    wstrb = Repeat(false)
    wlast = false
    bready = false
}


/// AXI_WIDTH can be 32, 64, 128, 256, or 512
/// sizeof#(T) should be divisible by 8 for <= AXI_WIDTH, and divisible by AXI_WIDTH for larger
module axi_memory_reader #(T, int AXI_WIDTH) {
    assert#(C: (AXI_WIDTH == 32) | (AXI_WIDTH == 64) | (AXI_WIDTH == 128) | (AXI_WIDTH == 256) | (AXI_WIDTH == 512))
    
    domain aclk
    input bool aresetn'0

    gen int ADDR_WIDTH = 64
    gen int ATO = pow2#(E: ADDR_WIDTH)
    gen int MAX_BURST = 256

    gen int NUM_TRANSFERS
    if sizeof#(T) <= AXI_WIDTH {
        NUM_TRANSFERS = 1
        assert#(C: sizeof#(T) % 8 == 0)
    } else {
        // Actually this code is fine even if it's not a multiple
        // assert#(C: sizeof#(T) % AXI_WIDTH == 0) // sizeof#(T) must be a multiple of AXI_WIDTH
        assert#(C: sizeof#(T) <= MAX_BURST * AXI_WIDTH) // T is too big!
        NUM_TRANSFERS = sizeof#(T) / AXI_WIDTH
        assert#(C: NUM_TRANSFERS < MAX_BURST) // T is too big!
        assert#(C: sizeof#(T) % AXI_WIDTH == 0)
    }

    // read channel
    output bool                     arvalid'0
    input  bool                     arready'0
    output int#(FROM: 0, TO: ATO)   araddr'0
    output int#(FROM: 0, TO: 256)   arlen'0
    output bool[2]                  arburst'0
    input  bool                     rvalid'0
    output bool                     rready'0
    input  bool[AXI_WIDTH]          rdata'0
    input  bool                     rlast'0

    // control signals
    // Returns "true" if the request was 
    action request : int#(FROM: 0, TO: ATO) addr -> bool fire {
        arvalid = true
        araddr = addr
        arlen = NUM_TRANSFERS - 1 // 0 is used for length '1', 1 for '2', etc. I think this is because a len-0 transfer makes no sense? 
        arburst = 2'b01 // BURST_INC
        fire = arready
    } else {
        arvalid = false
    }

    bool do_read
    bool do_read_was_valid
    bool[sizeof#(T)] do_read_data

    if sizeof#(T) <= AXI_WIDTH {
        // rlast should be true
        rready = do_read
        do_read_was_valid = rvalid
        do_read_data = rdata[:sizeof#(T)]
    } else if sizeof#(T) > AXI_WIDTH {
        state int#(FROM: 0, TO: NUM_TRANSFERS) stored_part_idx
        state bool[AXI_WIDTH][NUM_TRANSFERS - 1] stored_parts

        rready = false
        when stored_part_idx < NUM_TRANSFERS - 1 {
            do_read_was_valid = false
            rready = true
            when rvalid {
                int idx = unsafe_int_cast#(FROM: 0, TO: NUM_TRANSFERS - 1)(stored_part_idx)
                stored_parts[idx] = rdata
                stored_part_idx = idx + 1
            }
        } else {
            do_read_was_valid = rvalid
            rready = do_read
            when rready & rvalid {
                // rlast should be true
                stored_part_idx = 0
                for int i in 0..NUM_TRANSFERS-1 {
                    do_read_data[i * AXI_WIDTH +: AXI_WIDTH] = stored_parts[i]
                }
                do_read_data[(NUM_TRANSFERS - 1) * AXI_WIDTH +: AXI_WIDTH] = rdata
            }
        }
        when !aresetn {
            stored_part_idx = 0
        }
    }

    action read'0 : -> bool read_valid'0, T data'0 {
        do_read = true
        read_valid = do_read_was_valid
        when do_read_was_valid {
            data = transmute_from_bits(do_read_data)
        }
    } else {
        do_read = false
    }
}

/// AXI_WIDTH can be 32, 64, 128, 256, or 512
/// sizeof#(T) should be divisible by 8 for <= AXI_WIDTH, and divisible by AXI_WIDTH for larger
module axi_memory_writer #(T, int AXI_WIDTH) {
    assert#(C: (AXI_WIDTH == 32) | (AXI_WIDTH == 64) | (AXI_WIDTH == 128) | (AXI_WIDTH == 256) | (AXI_WIDTH == 512))
    
    domain aclk

    input bool aresetn


    gen int ADDR_WIDTH = 64
    gen int ATO = pow2#(E: ADDR_WIDTH)
    gen int MAX_BURST = 256
    gen int OUTSTANDING_WRITES_CAPACITY = 256

    gen int NUM_TRANSFERS
    if sizeof#(T) <= AXI_WIDTH {
        NUM_TRANSFERS = 1
        assert#(C: sizeof#(T) % 8 == 0)
    } else {
        // Actually this code is fine even if it's not a multiple
        // assert#(C: sizeof#(T) % AXI_WIDTH == 0) // sizeof#(T) must be a multiple of AXI_WIDTH
        assert#(C: sizeof#(T) <= MAX_BURST * AXI_WIDTH) // T is too big!
        NUM_TRANSFERS = sizeof#(T) / AXI_WIDTH
        assert#(C: NUM_TRANSFERS < MAX_BURST) // T is too big!
        assert#(C: sizeof#(T) % AXI_WIDTH == 0)
    }


    // axi mm master
    // write channels - tie off, never ready/valid
    output bool                     awvalid'0
    input  bool                     awready'0
    output int#(FROM: 0, TO: ATO)   awaddr'0
    output int#(FROM: 0, TO: 256)   awlen'0
    output bool[2]                  awburst'0
    output bool                     wvalid'0
    input  bool                     wready'0
    output bool[AXI_WIDTH]          wdata'0
    output bool[AXI_WIDTH / 8]      wstrb'0
    output bool                     wlast'0
    input  bool                     bvalid'0
    output bool                     bready'0
    // input  bool[2]                  bresp'0 // ignore bresp, we can't handle errors anyway

    state bool[sizeof#(T)] writing_data
    state bool writing_data_valid
    wvalid = writing_data_valid
    state int#(FROM: 0, TO: OUTSTANDING_WRITES_CAPACITY) num_outstanding_writes
    /// Used to check that all writes have been committed to memory before proceeding
    bready = num_outstanding_writes != 0

    if sizeof#(T) <= AXI_WIDTH {
        wlast = true
        for int BYTE in 0..AXI_WIDTH / 8 {
            if BYTE < sizeof#(T) / 8 {
                wdata[BYTE*8 +: 8] = writing_data
                wstrb[BYTE] = true
            } else {
                wdata[BYTE*8 +: 8] = 8'h00
                wstrb[BYTE] = false
            }
        }
        when wvalid & wready {
            writing_data_valid = false // fire!
        }
    } else {
        state int#(FROM: 0, TO: NUM_TRANSFERS) cur_data_chunk

        bool[AXI_WIDTH][NUM_TRANSFERS] parts
        for int i in 0..NUM_TRANSFERS {
            parts[i] = writing_data[i * AXI_WIDTH +: AXI_WIDTH]
        }

        wdata = parts[cur_data_chunk]
        wstrb = Repeat(true)
        wlast = !(cur_data_chunk < NUM_TRANSFERS - 1)

        when wvalid & wready {
            // fire!
            when !wlast {
                cur_data_chunk = unsafe_int_cast#(FROM: 0, TO: NUM_TRANSFERS - 1)(cur_data_chunk + 1)
            } else {
                writing_data_valid = false
            }
        }

        when awvalid & awready {
            cur_data_chunk = 0
            // writing_data is already written by the write action
        }
    }

    output bool has_outstanding_writes = bready
    action write : int#(FROM: 0, TO: ATO) addr, T data -> bool write_success {
        awlen = NUM_TRANSFERS - 1 // 0 is used for length '1', 1 for '2', etc. I think this is because a len-0 transfer makes no sense? 
        awburst = 2'b01 // BURST_INC
        awaddr = addr
        awvalid = !writing_data_valid & (num_outstanding_writes < OUTSTANDING_WRITES_CAPACITY - 1)
        write_success = awvalid & awready

        when awvalid & awready {
            writing_data = transmute_to_bits(data)
            writing_data_valid = true
        }
    } else {
        awvalid = false
    }

    when awvalid & awready & !(bvalid & bready) {
        num_outstanding_writes = unsafe_int_cast#(FROM: 0, TO: OUTSTANDING_WRITES_CAPACITY - 1)(num_outstanding_writes) + 1
    } else when bvalid & bready & !(awvalid & awready) {
        num_outstanding_writes = unsafe_int_cast#(FROM: 1, TO: OUTSTANDING_WRITES_CAPACITY)(num_outstanding_writes) - 1
    }

    when !aresetn {
        writing_data_valid = false
        num_outstanding_writes = 0
    }
}

/// Splits the given integer. The upper [LOWER_BITS:] bits are returned as upper, the lower [:LOWER_BITS] bits are returned in lower
/// See also [BitwiseIntConcat]
module BitwiseIntSplit #(int TO, int LOWER_BITS) {
    gen int UPPER_TO = (TO-1) / pow2#(E: LOWER_BITS) + 1
    interface BitwiseIntSplit :
        int#(FROM: 0, TO) v ->
        int#(FROM: 0, TO: UPPER_TO) upper,
        int#(FROM: 0, TO: pow2#(E: LOWER_BITS)) lower

    bool[clog2#(V: TO)] v_bits = UIntToBits(v)

    lower = BitsToUInt(v_bits[:LOWER_BITS])
    upper = transmute_from_bits#(T: type int#(FROM: 0, TO: UPPER_TO))(v_bits[LOWER_BITS:])
}

/// Recombines a lower and upper integer parts. 
/// See also [BitwiseIntSplit]
module BitwiseIntConcat #(int UPPER_TO, int LOWER_BITS) {
    interface BitwiseIntConcat :
        int#(FROM: 0, TO: UPPER_TO) upper,
        int#(FROM: 0, TO: pow2#(E: LOWER_BITS)) lower ->
        int#(FROM: 0, TO: UPPER_TO * pow2#(E: LOWER_BITS)) v

    bool[clog2#(V: UPPER_TO) + LOWER_BITS] v_bits
    v_bits[:LOWER_BITS] = UIntToBits(lower)
    v_bits[LOWER_BITS:] = UIntToBits(upper)
    v = transmute_from_bits#(T: type int#(FROM: 0, TO: UPPER_TO * pow2#(E: LOWER_BITS)))(v_bits)
}

/// Sets the lower [:LOWER_BITS] bits to false, thus aligning the value
/// Works for unsigned and signed integers alike
module AlignToPow2 #(int FROM, int TO, int LOWER_BITS) {
    gen int ALIGNED_FROM = FROM - FROM % clog2#(V: LOWER_BITS)
    gen int ALIGNED_TO = TO - (TO + 1) % clog2#(V: LOWER_BITS)
    interface AlignToPow2 :
        int#(FROM, TO) i ->
        int#(FROM: ALIGNED_FROM, TO: ALIGNED_TO) o

    bool[sizeof#(T: type int#(FROM, TO))] bits = transmute_to_bits(i)
    bool[sizeof#(T: type int#(FROM, TO))] aligned_bits
    aligned_bits[:LOWER_BITS] = Repeat(false)
    aligned_bits[LOWER_BITS:] = bits[LOWER_BITS:]
    o = transmute_from_bits#(T: type int#(FROM: ALIGNED_FROM, TO: ALIGNED_TO))(aligned_bits)
}

/// Allows us to update a blob of state with a pipelined update function
/// update() may only be called if may_update, upon which may_update goes low for UPDATE_PIPELINE_DEPTH cycles
module SlowState #(T, T RESET_TO, int OLD_DELAY, int NEW_DELAY) {
    assert#(C: OLD_DELAY >= 0)
    gen int UPDATE_TOTAL_DEPTH = max#(A: OLD_DELAY, B: OLD_DELAY + NEW_DELAY)
    domain clk
    input bool rst
    CrossDomain cross_rst
    cross_rst.in = rst

    domain data
    output state T old'-OLD_DELAY

    T new_s'NEW_DELAY
    bool update_s'0

    bool update_old'-OLD_DELAY = LatencyOffset#(OFFSET: -UPDATE_TOTAL_DEPTH)(update_s) // Despite their differing absolute latency, they of course need to be set back by the same amount, potentially introducing a pipeline stage
    T new_old'-OLD_DELAY = LatencyOffset#(OFFSET: -UPDATE_TOTAL_DEPTH)(new_s)
    when cross_rst.out {
        old = RESET_TO
    } else when update_old {
        old = new_old
    }

    output bool may_update'0
    action update'0 : T new'NEW_DELAY {
        update_s = true
        new_s = new
    } else {
        update_s = false
    }

    if UPDATE_TOTAL_DEPTH != 0 {
        state bool[UPDATE_TOTAL_DEPTH] cooldown
        may_update = cooldown[0]
        when update_s | cross_rst.out { // Importantly, there are no pipeline registers on update for the cooldown. Otherwise it could be called twice rapidly in a row
            cooldown = Repeat(false)
        } else {
            cooldown[0:UPDATE_TOTAL_DEPTH - 1] = cooldown[1:]
            cooldown[UPDATE_TOTAL_DEPTH - 1] = true
        }
    } else {
        may_update = true
    }
}

module IntToBool {
    interface IntToBool : int#(FROM: 0, TO: 2) i -> bool o

    o = i == 1
}
module BoolToInt {
    interface BoolToInt : bool i -> int#(FROM: 0, TO: 2) o

    when i {
        o = 1
    } else {
        o = 0
    }
}
module Ternary #(T) {
    interface Ternary : bool cond, T a, T b -> T o

    when cond {
        o = a
    } else {
        o = b
    }
}

module MakeStrobe #(int STROBE_WIDTH) {
    interface MakeStrobe : int#(FROM: 0, TO: STROBE_WIDTH) chunk_offset, int#(FROM: 1, TO: STROBE_WIDTH+1) chunk_length -> bool[STROBE_WIDTH] strobe

    bool[STROBE_WIDTH*2-1] chunk_bits
    chunk_bits[0] = true
    for int i in 1..STROBE_WIDTH {
        when chunk_length > i {
            chunk_bits[i] = true
        } else {
            chunk_bits[i] = false
        }
    }
    for int i in STROBE_WIDTH..STROBE_WIDTH-1 {
        chunk_bits[i] = false
    }

    strobe = chunk_bits[chunk_offset +: 8]
}

/*
Vivado Utiliziation report for axi_memory_burst_reader#(ElemT: type bool[32], AXI_WIDTH: 512, COUNT_TO: pow2#(E: 16))
+-------------------------+------+-------+------------+-----------+-------+
|        Site Type        | Used | Fixed | Prohibited | Available | Util% |
+-------------------------+------+-------+------------+-----------+-------+
| Registers               |  365 |     0 |          0 |   1799680 |  0.02 |
|   Register as Flip Flop |  365 |     0 |          0 |   1799680 |  0.02 |
|   Register as Latch     |    0 |     0 |          0 |   1799680 |  0.00 |
| CLB LUTs*               |  231 |     0 |          0 |    899840 |  0.03 |
|   LUT as Logic          |  231 |     0 |          0 |    899840 |  0.03 |
|   LUT as Memory         |    0 |     0 |          0 |    449920 |  0.00 |
| LOOKAHEAD8              |   12 |     0 |          0 |    112480 |  0.01 |
+-------------------------+------+-------+------------+-----------+-------+
*/
/// This core assumes UnitT elements are aligned to sizeof#(T: type UnitT)
/// This implies the element size must be a power of two
/// element - sizeof#(T: type ElemT) / 8 is minimum data alignment. It is also the resolution of count
/// chunk - one AXI transfer. Contains AXI_WIDTH / sizeof#(T: type ElemT) elements
/// burst - 1-256 chunks. Should not be visible outside of module
module axi_memory_burst_reader #(ElemT, int AXI_WIDTH, int COUNT_TO) {
    domain aclk
    input bool aresetn'0

    gen int AXI_WIDTH_BYTES = AXI_WIDTH / 8
    gen int AxSIZE = clog2#(V: AXI_WIDTH_BYTES)

    /// Check AXI_WIDTH is a power of two
    assert#(C: pow2#(E: AxSIZE) * 8 == AXI_WIDTH)
    /// AXI standard supported AXI_WIDTHs: 8 - 1024
    assert#(C: (AxSIZE >= 0) & (AxSIZE < 8))

    /// For XRT: Supported AXI_WIDTH ranges from 32-512
    assert#(C: (AXI_WIDTH == 32) | (AXI_WIDTH == 64) | (AXI_WIDTH == 128) | (AXI_WIDTH == 256) | (AXI_WIDTH == 512))

    gen int ADDR_WIDTH = 64
    gen int ATO = pow2#(E: ADDR_WIDTH)

    gen int MAX_AXI_ALIGNMENT = pow2#(E: 12)
    gen int MAX_BURST = MAX_AXI_ALIGNMENT / AXI_WIDTH_BYTES

    if MAX_BURST > 256 { // Limited to 256 for BURST_INCR - AXI4. (16 if AXI3, but we only support AXI4)
        MAX_BURST = 256
    }

    gen int MAX_CHUNKS_IN_FLIGHT = MAX_BURST + 128 // 128 cycles is the estimated max DDR latency, and we need MAX_BURST capacity 

    gen int ELEMENT_SIZE = sizeof#(T: type ElemT)
    gen int ELEMENT_BYTE_SIZE = ELEMENT_SIZE / 8
    /// The element size is a power of two
    assert#(C: pow2#(E: clog2#(V: ELEMENT_SIZE)) == ELEMENT_SIZE)
    gen int NUM_PARALLEL_ELEMENTS = AXI_WIDTH / ELEMENT_SIZE
    assert#(C: AXI_WIDTH % ELEMENT_SIZE == 0)
    gen int CHUNK_BYTE_SIZE = AXI_WIDTH / 8
    gen int CHUNKS_TO = (COUNT_TO + NUM_PARALLEL_ELEMENTS) / NUM_PARALLEL_ELEMENTS + 2

    // read channel
    output bool                     arvalid'0
    input  bool                     arready'0
    output int#(FROM: 0, TO: ATO)   araddr'0
    output int#(FROM: 0, TO: 256)   arlen'0
    output bool[2]                  arburst'0
    input  bool                     rvalid'0
    output bool                     rready'0
    input  bool[AXI_WIDTH]          rdata'0
    input  bool                     rlast'0
    arburst = 2'b01 // BURST

    // User ports
    input bool is_ready_to_receive_lots_of_data'-MAX_CHUNKS_IN_FLIGHT
    trigger element_packet_valid'0: ElemT[NUM_PARALLEL_ELEMENTS] elements'0, int#(FROM: 0, TO: NUM_PARALLEL_ELEMENTS) chunk_offset'0, int#(FROM: 0, TO: NUM_PARALLEL_ELEMENTS+1) chunk_length'0, bool last'0


    SlowState#(T: type int#(FROM: 0, TO: ATO / CHUNK_BYTE_SIZE), RESET_TO: 0) cur_start_chunk_addr
    SlowState#(T: type int#(FROM: 0, TO: CHUNKS_TO), RESET_TO: 0) num_chunks_left // When == 0 we're not transmitting
    state int#(FROM: 0, TO: MAX_CHUNKS_IN_FLIGHT) num_in_flight

    // araddr is always aligned to AxSIZE
    araddr = BitwiseIntConcat#(LOWER_BITS: clog2#(V: CHUNK_BYTE_SIZE))(cur_start_chunk_addr.old, 0)

    int cur_burst_addr, int cur_align = BitwiseIntSplit#(LOWER_BITS: clog2#(V: MAX_BURST))(cur_start_chunk_addr.old)

    // compute this_burst_size
    int this_burst_size
    reg bool chunks_are_left = num_chunks_left.old > 0
    when chunks_are_left {
        int max_chunks_in_this_burst = MAX_BURST - cur_align
        when num_chunks_left.old <= max_chunks_in_this_burst {
            reg this_burst_size = unsafe_int_cast#(FROM: 1, TO: MAX_BURST+1)(num_chunks_left.old)
        } else {
            reg this_burst_size = max_chunks_in_this_burst
        }
    }
    arlen = this_burst_size - 1

    arvalid = chunks_are_left & num_chunks_left.may_update & cur_start_chunk_addr.may_update & LatencyOffset#(OFFSET: MAX_CHUNKS_IN_FLIGHT)(is_ready_to_receive_lots_of_data) & (num_in_flight < MAX_CHUNKS_IN_FLIGHT - MAX_BURST)

    when arready & arvalid {
        reg int next_burst_addr = cur_burst_addr + 1
        cur_start_chunk_addr.update(unsafe_int_cast#(FROM: 0, TO: ATO / CHUNK_BYTE_SIZE)(BitwiseIntConcat#(LOWER_BITS: clog2#(V: MAX_BURST))(next_burst_addr, 0)))
        // SAFETY: we will never take off more chunks than are in num_chunks_left, of course
        int next_num_chunks_left = unsafe_int_cast#(FROM: 0, TO: CHUNKS_TO)(num_chunks_left.old - this_burst_size)
        num_chunks_left.update(next_num_chunks_left)
    }

    // We're always ready to send data
    rready = aresetn
    
    num_in_flight = unsafe_int_cast#(FROM: 0, TO: MAX_CHUNKS_IN_FLIGHT)(num_in_flight - BoolToInt(rvalid) + Ternary(arready & arvalid, this_burst_size, 0))
    
    state int#(FROM: 0, TO: CHUNKS_TO) chunks_left
    state int final_chunk_align
    state int cur_chunk_align // Only different from 0 on the first chunk
    when rvalid { // & true, due to rready being always true
        ElemT[NUM_PARALLEL_ELEMENTS] elements = transmute_from_bits#(T: type ElemT[NUM_PARALLEL_ELEMENTS])(rdata)
        int num_chunk_elements
        bool is_last = chunks_left == 1
        when is_last {
            num_chunk_elements = unsafe_int_cast#(FROM: 0, TO: NUM_PARALLEL_ELEMENTS + 1)(final_chunk_align - cur_chunk_align)
        } else {
            num_chunk_elements = NUM_PARALLEL_ELEMENTS - cur_chunk_align
        }
        
        element_packet_valid(elements, cur_chunk_align, num_chunk_elements, is_last)
        cur_chunk_align = 0
        chunks_left = unsafe_int_cast#(FROM: 0, TO: CHUNKS_TO)(chunks_left - 1)
    }


    output bool may_request_new_burst'0 = !chunks_are_left & num_chunks_left.may_update & cur_start_chunk_addr.may_update
    action request_new_burst'0 : int#(FROM: 0, TO: ATO) start_addr'0, int#(FROM: 0, TO: COUNT_TO) count'0 {
        int chunk_addr, int element_in_chunk_align = BitwiseIntSplit#(LOWER_BITS: clog2#(V: NUM_PARALLEL_ELEMENTS))(start_addr / ELEMENT_BYTE_SIZE)
        
        int chunk_count_bits, int final_alignment = BitwiseIntSplit#(LOWER_BITS: clog2#(V: NUM_PARALLEL_ELEMENTS))(count + element_in_chunk_align)
        int num_chunks
        bool is_no_chunks = chunk_count_bits == 0
        when is_no_chunks {
            num_chunks = 1 // Always do at least one chunk, that way we can output a last with strobe '0000
        } else {
            num_chunks = chunk_count_bits + BoolToInt(final_alignment != 0)
        }

        cur_start_chunk_addr.update(chunk_addr)
        num_chunks_left.update(num_chunks)

        final_chunk_align = BitwiseIntConcat#(LOWER_BITS: clog2#(V: NUM_PARALLEL_ELEMENTS))(BoolToInt(!is_no_chunks & (final_alignment == 0)), final_alignment)
        chunks_left = num_chunks
        cur_chunk_align = element_in_chunk_align
    }

    cur_start_chunk_addr.rst = !aresetn
    num_chunks_left.rst = !aresetn
    when !aresetn {
        num_in_flight = 0
    }
}

module test_burst_reader {
    axi_memory_burst_reader #(ElemT: type bool[16], AXI_WIDTH: 64, COUNT_TO: pow2#(E: 16)) reader
    axi_memory_burst_reader #(ElemT: type bool[32], AXI_WIDTH: 512, COUNT_TO: pow2#(E: 16)) fullFatReader
}
