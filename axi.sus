
module axis_master_fifo#(T, int DEPTH, int MAY_PUSH_LATENCY) {
    input bool aresetn'0

    input bool tready'0
    output bool tvalid'0
    output bool[sizeof#(T)] tdata'0

    /// Basically the same as a FWFT XPM FIFO, just that we can't yet instantiate that one without an extra SV file. (#131)
    state T[DEPTH] memory
    state int#(FROM: 0, TO: DEPTH) wr_addr
    state int#(FROM: 0, TO: DEPTH) rd_addr
    
    bool do_read = !tvalid | tready & tvalid

    gen int NUM_PIPELINE_STAGES
    if DEPTH <= 64 {
        NUM_PIPELINE_STAGES = 1
    } else {
        NUM_PIPELINE_STAGES = 2
    }
    state T[NUM_PIPELINE_STAGES] memory_read_pipeline_stages
    state bool[NUM_PIPELINE_STAGES] memory_read_pipeline_stages_valids
    when do_read {
        for int i in 1..NUM_PIPELINE_STAGES {
            memory_read_pipeline_stages[i] = memory_read_pipeline_stages[i-1]
            memory_read_pipeline_stages_valids[i] = memory_read_pipeline_stages_valids[i-1]
        }
        bool read_from_mem_is_valid = rd_addr != wr_addr
        memory_read_pipeline_stages_valids[0] = read_from_mem_is_valid
        when read_from_mem_is_valid {
            memory_read_pipeline_stages[0] = memory[rd_addr]
            rd_addr = (rd_addr + 1) % DEPTH
        }
    }

    tdata = transmute_to_bits(memory_read_pipeline_stages[NUM_PIPELINE_STAGES - 1])
    tvalid = memory_read_pipeline_stages_valids[NUM_PIPELINE_STAGES - 1]

    int free_space = (rd_addr - wr_addr - 1) % DEPTH

    output bool may_push'-MAY_PUSH_LATENCY
    may_push = LatencyOffset#(OFFSET: -MAY_PUSH_LATENCY)(free_space >= MAY_PUSH_LATENCY)
    action push'0: T data'0 {
        memory[wr_addr] = data
        wr_addr = (wr_addr + 1) % DEPTH
    }

    when !aresetn {
        wr_addr = 0
        rd_addr = 0

        for int i in 0..NUM_PIPELINE_STAGES {
            memory_read_pipeline_stages_valids[i] = false
        }
    }
}
/*module use_axis_master_fifo {
    axis_master_fifo#(T: type bool, DEPTH: 0, MAY_PUSH_LATENCY: 12) m
}*/

/// CTRL REGS is 0x000000
/// Input regs start at 0x000010 and increment 0X000008 every time
/// Output regs start at end of input regs
///
/// XRT imposes a 64K (16bit) address range limitation. 
/// See https://docs.amd.com/r/2023.2-English/ug1393-vitis-application-acceleration/Kernel-Interface-Requirements
///
/// It also appears that ADDR_WIDTH must be >= 12, because the address mapping requires blocks of size 4096
module axi_ctrl_slave #(int NUM_INPUT_REGS, int NUM_OUTPUT_REGS, int ADDR_WIDTH, int AXI_WIDTH) {
    domain aclk
    input bool aresetn

    gen int DATA_STARTS_AT_ADDR = 16 // 0x010
    gen int REG_STRIDE = AXI_WIDTH / 8
    gen int CTRL_REG = 0
    gen int FIRST_REG = DATA_STARTS_AT_ADDR / REG_STRIDE
    assert#(C: DATA_STARTS_AT_ADDR % REG_STRIDE == 0)
    gen int ATO = pow2#(E: ADDR_WIDTH)
    assert#(C: ADDR_WIDTH >= 12)
    assert#(C: ADDR_WIDTH <= 16)
    // Max number of regs
    assert#(C: (FIRST_REG + NUM_INPUT_REGS + NUM_OUTPUT_REGS) * REG_STRIDE <= pow2#(E: ADDR_WIDTH))
    gen bool[2] RESP_OKAY = [false, false]
    gen bool[2] RESP_SLVERR = [false, true]

    // AXI signals
    input int#(FROM: 0, TO: ATO) awaddr
    input bool awvalid
    output bool awready = false
    input bool[AXI_WIDTH] wdata
    input bool[AXI_WIDTH / 8] wstrb
    input bool wvalid
    output bool wready = false
    output bool[2] bresp
    output bool bvalid = false
    input bool bready
    input int#(FROM: 0, TO: ATO) araddr
    input bool arvalid
    output bool arready = false
    output bool[AXI_WIDTH] rdata
    output bool[2] rresp
    output bool rvalid = false
    input bool rready


    state bool[32][NUM_OUTPUT_REGS] stored_output_regs
    output state bool[32][NUM_INPUT_REGS] input_regs
    trigger start

    // control register bits
    state bool reg_ctrl_ap_idle
    state bool reg_ctrl_ap_done
    bool reg_ctrl_ap_ready = reg_ctrl_ap_done    // copy ap_done because there's no pausing
    state bool reg_ctrl_ap_start

    // Write transaction
    state int stored_addr
    state bool stored_addr_valid
    state bool[2] last_bresp
    state bool last_werr_valid
    
    awready = !stored_addr_valid & aresetn // Force low on reset
    wready = stored_addr_valid & !last_werr_valid // Already low by reset
    bvalid = last_werr_valid
    bresp = last_bresp

    when awready & awvalid {
        stored_addr_valid = true
        stored_addr = awaddr / REG_STRIDE
    }
    when wready & wvalid {
        stored_addr_valid = false
        last_werr_valid = true

        last_bresp = RESP_SLVERR
        when stored_addr == CTRL_REG {
            when wstrb[0] & wdata[0] {
                reg_ctrl_ap_start = true
                reg_ctrl_ap_idle = false
                start()
            }
            last_bresp = RESP_OKAY
        }
        // Data Write
        when (stored_addr >= FIRST_REG) & (stored_addr < FIRST_REG + NUM_INPUT_REGS) {
            int write_idx = unsafe_int_cast#(FROM: FIRST_REG, TO: FIRST_REG + NUM_INPUT_REGS)(stored_addr) - FIRST_REG
            for int strbi in 0..4 {
                when wstrb[strbi] {
                    input_regs[write_idx][strbi*8 +: 8] = wdata[strbi*8 +: 8]
                }
            }
            last_bresp = RESP_OKAY
        }
    }
    when bready & bvalid {
        last_werr_valid = false
    }

    // Read transaction
    state bool last_rdata_valid
    state bool[32] last_rdata
    rdata = last_rdata
    state bool[2] last_rresp
    rresp = last_rresp

    bool[32][NUM_INPUT_REGS + NUM_OUTPUT_REGS] regs_read_multiplexer
    regs_read_multiplexer[:NUM_INPUT_REGS] = input_regs
    regs_read_multiplexer[NUM_INPUT_REGS:] = stored_output_regs

    arready = !last_rdata_valid & aresetn // Force low on reset
    rvalid = last_rdata_valid // Already low by reset

    when arready & arvalid {
        last_rdata_valid = true
        
        // Control Read
        last_rresp = RESP_SLVERR
        int read_addr = araddr / REG_STRIDE
        when read_addr == CTRL_REG {
            last_rdata[0] = reg_ctrl_ap_start
            last_rdata[1] = reg_ctrl_ap_done
            last_rdata[2] = reg_ctrl_ap_idle
            last_rdata[3] = reg_ctrl_ap_ready
            last_rdata[4:] = Repeat(false)
            when reg_ctrl_ap_done {
                reg_ctrl_ap_idle = true
            }
            reg_ctrl_ap_done = false // clear on read
            last_rresp = RESP_OKAY
        }
        // Data Read
        when (read_addr >= FIRST_REG) & (read_addr < FIRST_REG + NUM_INPUT_REGS + NUM_OUTPUT_REGS) {
            int read_idx = unsafe_int_cast#(FROM: FIRST_REG, TO: FIRST_REG + NUM_INPUT_REGS + NUM_OUTPUT_REGS)(read_addr) - FIRST_REG
            last_rdata = regs_read_multiplexer[read_idx]
            last_rresp = RESP_OKAY
        }
    }
    when rready & rvalid {
        last_rdata_valid = false
    }

    action finish : bool[32][NUM_OUTPUT_REGS] output_regs {
        stored_output_regs = output_regs
        reg_ctrl_ap_done = true
        reg_ctrl_ap_start = false
        reg_ctrl_ap_idle = false
    }

    when !aresetn {
        stored_addr_valid = false
        last_werr_valid = false

        last_rdata_valid = false

        reg_ctrl_ap_idle = true
        reg_ctrl_ap_start = false
        reg_ctrl_ap_done = false

        input_regs = Repeat(Repeat(false))
        stored_output_regs = Repeat(Repeat(false))
    }
}


module axi_memory_reader_tie_off#(int AXI_WIDTH) {
    domain aclk
    input bool aresetn'0

    gen int ADDR_WIDTH = 64
    gen int ATO = pow2#(E: ADDR_WIDTH)

    // axi mm master
    // read channels - tie off, never ready/valid
    output bool                     arvalid'0 = false
    input  bool                     arready'0
    output int#(FROM: 0, TO: ATO)   araddr'0 = 0
    output int#(FROM: 0, TO: 256)   arlen'0 = 0
    output int#(FROM: 0, TO: 8)     arsize'0 = clog2#(V: AXI_WIDTH / 8)
    output bool[2]                  arburst'0 = 2'b00
    output bool[3]                  arprot'0 = 3'b00
    output bool[4]                  arcache'0 = 4'b0000
    output int#(FROM: 0, TO: 16)    arqos'0 = 0
    output bool                     arlock'0 = false
    output int#(FROM: 0, TO: 16)    arregion'0 = 0
    input  bool                     rvalid'0
    output bool                     rready'0 = false
    input  bool[AXI_WIDTH]          rdata'0
    input  bool[2]                  rresp'0
    input  bool                     rlast'0
}

module axi_memory_writer_tie_off#(int AXI_WIDTH) {
    domain aclk
    input bool aresetn'0

    gen int ADDR_WIDTH = 64
    gen int ATO = pow2#(E: ADDR_WIDTH)

    // axi mm master
    // write channels - tie off, never ready/valid
    output bool                     awvalid'0 = false
    input  bool                     awready'0 
    output int#(FROM: 0, TO: ATO)   awaddr'0 = 0
    output int#(FROM: 0, TO: 256)   awlen'0 = 0
    output int#(FROM: 0, TO: 8)     awsize'0 = clog2#(V: AXI_WIDTH / 8)
    output bool[2]                  awburst'0 = 2'b00
    output bool[3]                  awprot'0 = 3'b000
    output bool[4]                  awcache'0 = 4'b0000
    output int#(FROM: 0, TO: 16)    awqos'0 = 0
    output bool                     awlock'0 = false
    output int#(FROM: 0, TO: 16)    awregion'0 = 0
    output bool                     wvalid'0 = false
    input  bool                     wready'0
    output bool[AXI_WIDTH]          wdata'0 = Repeat(false)
    output bool[AXI_WIDTH / 8]      wstrb'0 = Repeat(false)
    output bool                     wlast'0 = false
    input  bool                     bvalid'0
    input  bool[2]                  bresp'0
    output bool                     bready'0 = false
}


/// AXI_WIDTH can be 32, 64, 128, 256, or 512
/// sizeof#(T) should be divisible by 8 for <= AXI_WIDTH, and divisible by AXI_WIDTH for larger
module axi_memory_reader #(T, int AXI_WIDTH) {
    assert#(C: (AXI_WIDTH == 32) | (AXI_WIDTH == 64) | (AXI_WIDTH == 128) | (AXI_WIDTH == 256) | (AXI_WIDTH == 512))
    
    domain aclk
    input bool aresetn'0

    gen int ADDR_WIDTH = 64
    gen int ATO = pow2#(E: ADDR_WIDTH)
    gen int MAX_BURST = 256

    gen int NUM_TRANSFERS
    if sizeof#(T) <= AXI_WIDTH {
        NUM_TRANSFERS = 1
        assert#(C: sizeof#(T) % 8 == 0)
    } else {
        // Actually this code is fine even if it's not a multiple
        // assert#(C: sizeof#(T) % AXI_WIDTH == 0) // sizeof#(T) must be a multiple of AXI_WIDTH
        assert#(C: sizeof#(T) <= MAX_BURST * AXI_WIDTH) // T is too big!
        NUM_TRANSFERS = sizeof#(T) / AXI_WIDTH
        assert#(C: NUM_TRANSFERS < MAX_BURST) // T is too big!
        assert#(C: sizeof#(T) % AXI_WIDTH == 0)
    }

    // read channel
    output bool                     arvalid'0
    input  bool                     arready'0
    output int#(FROM: 0, TO: ATO)   araddr'0
    output int#(FROM: 0, TO: 256)   arlen'0
    output int#(FROM: 0, TO: 8)     arsize'0 = clog2#(V: AXI_WIDTH / 8)
    output bool[2]                  arburst'0 = 2'b01 // BURST_INC
    output bool[3]                  arprot'0 = 3'b000 // Unprivileged, Secure, Data Access
    output bool[4]                  arcache'0 = 4'b0010 // Not bufferable, but can be broken up (into 128-bit, or other)
    output int#(FROM: 0, TO: 16)    arqos'0 = 0 // Lowest priority
    output bool                     arlock'0 = false // NORMAL - No atomics
    output int#(FROM: 0, TO: 16)    arregion'0 = 0 // Region 0
    input  bool                     rvalid'0
    output bool                     rready'0
    input  bool[AXI_WIDTH]          rdata'0
    input  bool[2]                  rresp'0
    input  bool                     rlast'0

    // control signals
    // Returns "true" if the request was 
    action request : int#(FROM: 0, TO: ATO) addr -> bool fire {
        arvalid = true
        araddr = addr
        arlen = NUM_TRANSFERS - 1 // 0 is used for length '1', 1 for '2', etc. I think this is because a len-0 transfer makes no sense? 
        fire = arready
    } else {
        arvalid = false
    }

    bool do_read
    bool do_read_was_valid
    bool[sizeof#(T)] do_read_data

    if sizeof#(T) <= AXI_WIDTH {
        // rlast should be true
        rready = do_read
        do_read_was_valid = rvalid
        do_read_data = rdata[:sizeof#(T)]
    } else if sizeof#(T) > AXI_WIDTH {
        state int#(FROM: 0, TO: NUM_TRANSFERS) stored_part_idx
        state bool[AXI_WIDTH][NUM_TRANSFERS - 1] stored_parts

        rready = false
        when stored_part_idx < NUM_TRANSFERS - 1 {
            do_read_was_valid = false
            rready = true
            when rvalid {
                int idx = unsafe_int_cast#(FROM: 0, TO: NUM_TRANSFERS - 1)(stored_part_idx)
                stored_parts[idx] = rdata
                stored_part_idx = idx + 1
            }
        } else {
            do_read_was_valid = rvalid
            rready = do_read
            when rready & rvalid {
                // rlast should be true
                stored_part_idx = 0
                for int i in 0..NUM_TRANSFERS-1 {
                    do_read_data[i * AXI_WIDTH +: AXI_WIDTH] = stored_parts[i]
                }
                do_read_data[(NUM_TRANSFERS - 1) * AXI_WIDTH +: AXI_WIDTH] = rdata
            }
        }
        when !aresetn {
            stored_part_idx = 0
        }
    }

    action read'0 : -> bool read_valid'0, T data'0 {
        do_read = true
        read_valid = do_read_was_valid
        when do_read_was_valid {
            data = transmute_from_bits(do_read_data)
        }
    } else {
        do_read = false
    }
}

/// AXI_WIDTH can be 32, 64, 128, 256, or 512
/// sizeof#(T) should be divisible by 8 for <= AXI_WIDTH, and divisible by AXI_WIDTH for larger
module axi_memory_writer #(T, int AXI_WIDTH) {
    assert#(C: (AXI_WIDTH == 32) | (AXI_WIDTH == 64) | (AXI_WIDTH == 128) | (AXI_WIDTH == 256) | (AXI_WIDTH == 512))
    
    domain aclk

    input bool aresetn


    gen int ADDR_WIDTH = 64
    gen int ATO = pow2#(E: ADDR_WIDTH)
    gen int MAX_BURST = 256
    gen int OUTSTANDING_WRITES_CAPACITY = 256

    gen int NUM_TRANSFERS
    if sizeof#(T) <= AXI_WIDTH {
        NUM_TRANSFERS = 1
        assert#(C: sizeof#(T) % 8 == 0)
    } else {
        // Actually this code is fine even if it's not a multiple
        // assert#(C: sizeof#(T) % AXI_WIDTH == 0) // sizeof#(T) must be a multiple of AXI_WIDTH
        assert#(C: sizeof#(T) <= MAX_BURST * AXI_WIDTH) // T is too big!
        NUM_TRANSFERS = sizeof#(T) / AXI_WIDTH
        assert#(C: NUM_TRANSFERS < MAX_BURST) // T is too big!
        assert#(C: sizeof#(T) % AXI_WIDTH == 0)
    }


    // axi mm master
    // write channels - tie off, never ready/valid
    output bool                     awvalid'0
    input  bool                     awready'0
    output int#(FROM: 0, TO: ATO)   awaddr'0
    output int#(FROM: 0, TO: 256)   awlen'0
    output int#(FROM: 0, TO: 8)     awsize'0 = clog2#(V: AXI_WIDTH / 8)
    output bool[2]                  awburst'0
    output bool[3]                  awprot'0 = 3'b000 // Unprivileged, Secure, Data Access
    output bool[4]                  awcache'0 = 4'b0010 // Not bufferable, but can be broken up (into 128-bit, or other)
    output int#(FROM: 0, TO: 16)    awqos'0 = 0 // Lowest priority
    output bool                     awlock'0 = false // NORMAL - No atomics
    output int#(FROM: 0, TO: 16)    awregion'0 = 0 // Region 0
    output bool                     wvalid'0
    input  bool                     wready'0
    output bool[AXI_WIDTH]          wdata'0
    output bool[AXI_WIDTH / 8]      wstrb'0
    output bool                     wlast'0
    input  bool                     bvalid'0
    output bool                     bready'0
    input  bool[2]                  bresp'0 // ignore bresp, we can't handle errors anyway

    state bool[sizeof#(T)] writing_data
    state bool writing_data_valid
    wvalid = writing_data_valid
    state int#(FROM: 0, TO: OUTSTANDING_WRITES_CAPACITY) num_outstanding_writes
    /// Used to check that all writes have been committed to memory before proceeding
    bready = num_outstanding_writes != 0

    if sizeof#(T) <= AXI_WIDTH {
        wlast = true
        for int BYTE in 0..AXI_WIDTH / 8 {
            if BYTE < sizeof#(T) / 8 {
                wdata[BYTE*8 +: 8] = writing_data
                wstrb[BYTE] = true
            } else {
                wdata[BYTE*8 +: 8] = 8'h00
                wstrb[BYTE] = false
            }
        }
        when wvalid & wready {
            writing_data_valid = false // fire!
        }
    } else {
        state int#(FROM: 0, TO: NUM_TRANSFERS) cur_data_chunk

        bool[AXI_WIDTH][NUM_TRANSFERS] parts
        for int i in 0..NUM_TRANSFERS {
            parts[i] = writing_data[i * AXI_WIDTH +: AXI_WIDTH]
        }

        wdata = parts[cur_data_chunk]
        wstrb = Repeat(true)
        wlast = !(cur_data_chunk < NUM_TRANSFERS - 1)

        when wvalid & wready {
            // fire!
            when !wlast {
                cur_data_chunk = unsafe_int_cast#(FROM: 0, TO: NUM_TRANSFERS - 1)(cur_data_chunk + 1)
            } else {
                writing_data_valid = false
            }
        }

        when awvalid & awready {
            cur_data_chunk = 0
            // writing_data is already written by the write action
        }
    }

    output bool has_outstanding_writes = bready
    action write : int#(FROM: 0, TO: ATO) addr, T data -> bool write_success {
        awlen = NUM_TRANSFERS - 1 // 0 is used for length '1', 1 for '2', etc. I think this is because a len-0 transfer makes no sense? 
        awburst = 2'b01 // BURST_INC
        awaddr = addr
        awvalid = !writing_data_valid & (num_outstanding_writes < OUTSTANDING_WRITES_CAPACITY - 1)
        write_success = awvalid & awready

        when awvalid & awready {
            writing_data = transmute_to_bits(data)
            writing_data_valid = true
        }
    } else {
        awvalid = false
    }

    when awvalid & awready & !(bvalid & bready) {
        num_outstanding_writes = unsafe_int_cast#(FROM: 0, TO: OUTSTANDING_WRITES_CAPACITY - 1)(num_outstanding_writes) + 1
    } else when bvalid & bready & !(awvalid & awready) {
        num_outstanding_writes = unsafe_int_cast#(FROM: 1, TO: OUTSTANDING_WRITES_CAPACITY)(num_outstanding_writes) - 1
    }

    when !aresetn {
        writing_data_valid = false
        num_outstanding_writes = 0
    }
}

module MakeStrobe #(int STROBE_WIDTH) {
    interface MakeStrobe : int#(FROM: 0, TO: STROBE_WIDTH) chunk_offset'0, int#(FROM: 0, TO: STROBE_WIDTH+1) chunk_length'0 -> bool[STROBE_WIDTH] strobe

    bool[STROBE_WIDTH] chunk_bits
    for int I in 0..STROBE_WIDTH {
        when chunk_length > I {
            chunk_bits[I] = true
        } else {
            chunk_bits[I] = false
        }
    }

    strobe = RotateRight(chunk_bits, chunk_offset)
}

/*
Vivado Utiliziation report for axi_array_burst_reader#(AXI_WIDTH: 512, ADDR_ALIGN: 4, COUNT_TO: pow2#(E: 16), ATO: pow2#(E: 64))
+-------------------------+------+-------+------------+-----------+-------+
|        Site Type        | Used | Fixed | Prohibited | Available | Util% |
+-------------------------+------+-------+------------+-----------+-------+
| Registers               |  365 |     0 |          0 |   1799680 |  0.02 |
|   Register as Flip Flop |  365 |     0 |          0 |   1799680 |  0.02 |
|   Register as Latch     |    0 |     0 |          0 |   1799680 |  0.00 |
| CLB LUTs*               |  231 |     0 |          0 |    899840 |  0.03 |
|   LUT as Logic          |  231 |     0 |          0 |    899840 |  0.03 |
|   LUT as Memory         |    0 |     0 |          0 |    449920 |  0.00 |
| LOOKAHEAD8              |   12 |     0 |          0 |    112480 |  0.01 |
+-------------------------+------+-------+------------+-----------+-------+
*/
/// A Bursting AXI reader. It spends as little logic as possible, so aligning and backpressure are up to the user. 
///
/// Alignment is not handled by this module. Chunks are delivered on element_packet_valid with a size and valid chunk count. Data is not necessarily aligned to the start of the chunk. For alignment see [axi_burst_reader]
///
/// Very coarse backpressure is provided in the form of the `is_ready_to_receive_lots_of_data` wire. Its latency count is set such that a receiving FIFO can set its ALMOST_FULL treshold to receive all elements in flight (around 192..384). Can be set to constant 'true' if no backpressure needed
/// 
/// element: size is ADDR_ALIGN * 8. It is also the resolution of count
/// chunk: one AXI transfer. Contains AXI_WIDTH / (ADDR_ALIGN * 8) elements
/// burst: 1-256 chunks. The module handles converting the user's large bitwidth element `count` into a sequence of 4K page aligned bursts. `last` is only asserted at the end of the whole read
module axi_array_burst_reader #(int AXI_WIDTH, int ADDR_ALIGN, int COUNT_TO, int ATO) {
    domain aclk
    input bool aresetn'0

    gen int AXI_WIDTH_BYTES = AXI_WIDTH / 8
    gen int AxSIZE = clog2#(V: AXI_WIDTH_BYTES)

    /// Check AXI_WIDTH is a power of two
    assert#(C: pow2#(E: AxSIZE) * 8 == AXI_WIDTH)
    /// AXI standard supported AXI_WIDTHs: 8 - 1024
    assert#(C: (AxSIZE >= 0) & (AxSIZE < 8))

    /// For XRT: Supported AXI_WIDTH ranges from 32-512
    assert#(C: (AXI_WIDTH == 32) | (AXI_WIDTH == 64) | (AXI_WIDTH == 128) | (AXI_WIDTH == 256) | (AXI_WIDTH == 512))

    gen int MAX_AXI_ALIGNMENT = pow2#(E: 12)
    gen int MAX_BURST = MAX_AXI_ALIGNMENT / AXI_WIDTH_BYTES

    if MAX_BURST > 256 { // Limited to 256 for BURST_INCR - AXI4. (16 if AXI3, but we only support AXI4)
        MAX_BURST = 256
    }

    gen int MAX_CHUNKS_IN_FLIGHT = MAX_BURST + 128 // 128 cycles is the estimated max DDR latency, and we need MAX_BURST capacity 

    gen int ELEMENT_BITWIDTH = ADDR_ALIGN * 8
    /// The alignment is a power of two
    assert#(C: pow2#(E: clog2#(V: ADDR_ALIGN)) == ADDR_ALIGN)
    gen int NUM_PARALLEL_ELEMENTS = AXI_WIDTH / ELEMENT_BITWIDTH
    assert#(C: AXI_WIDTH % ELEMENT_BITWIDTH == 0)
    gen int CHUNK_BYTE_SIZE = AXI_WIDTH / 8
    gen int CHUNKS_TO = (COUNT_TO + NUM_PARALLEL_ELEMENTS) / NUM_PARALLEL_ELEMENTS + 2

    // axi interface
    output bool                     arvalid'0
    input  bool                     arready'0
    output int#(FROM: 0, TO: ATO)   araddr'0
    output int#(FROM: 0, TO: 256)   arlen'0
    output int#(FROM: 0, TO: 8)     arsize'0 = clog2#(V: AXI_WIDTH / 8)
    output bool[2]                  arburst'0 = 2'b01 // BURST_INC
    output bool[3]                  arprot'0 = 3'b000 // Unprivileged, Secure, Data Access
    output bool[4]                  arcache'0 = 4'b0010 // Not bufferable, but can be broken up (into 128-bit, or other)
    output int#(FROM: 0, TO: 16)    arqos'0 = 0 // Lowest priority
    output bool                     arlock'0 = false // NORMAL - No atomics
    output int#(FROM: 0, TO: 16)    arregion'0 = 0 // Region 0
    input  bool                     rvalid'0
    output bool                     rready'0
    input  bool[AXI_WIDTH]          rdata'0
    input  bool[2]                  rresp'0
    input  bool                     rlast'0
    bool _ = rlast

    // User ports
    input bool is_ready_to_receive_lots_of_data'-MAX_CHUNKS_IN_FLIGHT
    trigger element_packet_valid'0: bool[ELEMENT_BITWIDTH][NUM_PARALLEL_ELEMENTS] elements'0, int#(FROM: 0, TO: NUM_PARALLEL_ELEMENTS) chunk_offset'0, int#(FROM: 0, TO: NUM_PARALLEL_ELEMENTS+1) chunk_length'0, bool last'0


    SlowState#(T: type int#(FROM: 0, TO: ATO / CHUNK_BYTE_SIZE), RESET_TO: 0) cur_start_chunk_addr
    SlowState#(T: type int#(FROM: 0, TO: CHUNKS_TO), RESET_TO: 0) num_chunks_left // When == 0 we're not transmitting
    state int#(FROM: 0, TO: MAX_CHUNKS_IN_FLIGHT) num_in_flight

    // araddr is always aligned to AxSIZE
    araddr = BitwiseIntConcat#(LOWER_BITS: clog2#(V: CHUNK_BYTE_SIZE))(cur_start_chunk_addr.old, 0)

    int cur_burst_addr, int cur_align = BitwiseIntSplit#(LOWER_BITS: clog2#(V: MAX_BURST))(cur_start_chunk_addr.old)

    // compute this_burst_size
    int this_burst_size
    reg bool chunks_are_left = num_chunks_left.old > 0
    when chunks_are_left {
        int max_chunks_in_this_burst = MAX_BURST - cur_align
        when num_chunks_left.old <= max_chunks_in_this_burst {
            reg this_burst_size = unsafe_int_cast#(FROM: 1, TO: MAX_BURST+1)(num_chunks_left.old)
        } else {
            reg this_burst_size = max_chunks_in_this_burst
        }
    }
    arlen = this_burst_size - 1

    arvalid = chunks_are_left & num_chunks_left.may_update & cur_start_chunk_addr.may_update & LatencyOffset#(OFFSET: MAX_CHUNKS_IN_FLIGHT)(is_ready_to_receive_lots_of_data) & (num_in_flight < MAX_CHUNKS_IN_FLIGHT - MAX_BURST)

    when arready & arvalid {
        reg int next_burst_addr = cur_burst_addr + 1
        cur_start_chunk_addr.update(unsafe_int_cast#(FROM: 0, TO: ATO / CHUNK_BYTE_SIZE)(BitwiseIntConcat#(LOWER_BITS: clog2#(V: MAX_BURST))(next_burst_addr, 0)))
        // SAFETY: we will never take off more chunks than are in num_chunks_left, of course
        int next_num_chunks_left = unsafe_int_cast#(FROM: 0, TO: CHUNKS_TO)(num_chunks_left.old - this_burst_size)
        num_chunks_left.update(next_num_chunks_left)
    }

    // We're always ready to send data
    rready = aresetn
    
    num_in_flight = unsafe_int_cast#(FROM: 0, TO: MAX_CHUNKS_IN_FLIGHT)(num_in_flight - BoolToInt(rvalid) + Ternary(arready & arvalid, this_burst_size, 0))
    
    state int#(FROM: 0, TO: CHUNKS_TO) chunks_left
    state int final_chunk_align
    state int cur_chunk_align // Only different from 0 on the first chunk
    when rvalid { // & true, due to rready being always true
        bool[ELEMENT_BITWIDTH][NUM_PARALLEL_ELEMENTS] elements
        for int ELEMENT_I in 0..NUM_PARALLEL_ELEMENTS {
            elements[ELEMENT_I] = rdata[ELEMENT_I * ELEMENT_BITWIDTH +: ELEMENT_BITWIDTH]
        }
        int num_chunk_elements
        bool is_last = chunks_left == 1
        when is_last {
            num_chunk_elements = unsafe_int_cast#(FROM: 0, TO: NUM_PARALLEL_ELEMENTS + 1)(final_chunk_align - cur_chunk_align)
        } else {
            num_chunk_elements = NUM_PARALLEL_ELEMENTS - cur_chunk_align
        }
        
        element_packet_valid(elements, cur_chunk_align, num_chunk_elements, is_last)
        cur_chunk_align = 0
        chunks_left = unsafe_int_cast#(FROM: 0, TO: CHUNKS_TO)(chunks_left - 1)
    }


    output bool may_request_new_burst'0 = !chunks_are_left & num_chunks_left.may_update & cur_start_chunk_addr.may_update
    action request_new_burst'0 : int#(FROM: 0, TO: ATO) start_addr'0, int#(FROM: 0, TO: COUNT_TO) count'0 {
        int chunk_addr, int element_in_chunk_align = BitwiseIntSplit#(LOWER_BITS: clog2#(V: NUM_PARALLEL_ELEMENTS))(start_addr / ADDR_ALIGN)
        
        int chunk_count_bits, int final_alignment = BitwiseIntSplit#(LOWER_BITS: clog2#(V: NUM_PARALLEL_ELEMENTS))(count + element_in_chunk_align)
        int num_chunks
        bool is_no_chunks = chunk_count_bits == 0
        when is_no_chunks {
            num_chunks = 1 // Always do at least one chunk, that way we can output a last with strobe '0000
        } else {
            num_chunks = chunk_count_bits + BoolToInt(final_alignment != 0)
        }

        cur_start_chunk_addr.update(chunk_addr)
        num_chunks_left.update(num_chunks)

        final_chunk_align = BitwiseIntConcat#(LOWER_BITS: clog2#(V: NUM_PARALLEL_ELEMENTS))(BoolToInt(!is_no_chunks & (final_alignment == 0)), final_alignment)
        chunks_left = num_chunks
        cur_chunk_align = element_in_chunk_align
    }

    cur_start_chunk_addr.rst = !aresetn
    num_chunks_left.rst = !aresetn
    when !aresetn {
        num_in_flight = 0
    }
}

/// A Bursting and aligning AXI reader.
/// 
/// As 
/// 
/// Very coarse backpressure is provided in the form of the `is_ready_to_receive_lots_of_data` wire. Its latency count is set such that a receiving FIFO can set its ALMOST_FULL treshold to receive all elements in flight (around 192..384). Can be set to constant 'true' if no backpressure needed
/// 
/// `last` is asserted for the last value
module axi_realigning_burst_reader #(T, int AXI_WIDTH, int ADDR_ALIGN, int COUNT_TO, int ATO) {
    domain aclk
    input bool aresetn

    assert#(C: sizeof#(T) % (ADDR_ALIGN * 8) == 0)
    gen int ELEMENT_BITWIDTH = ADDR_ALIGN * 8
    gen int NUM_ELEMENTS_PER_VALUE = sizeof#(T) / ELEMENT_BITWIDTH
    gen int NUM_PARALLEL_ELEMENTS = AXI_WIDTH / ELEMENT_BITWIDTH
    // When T is bigger than AXI_WIDTH, multiple output cycles would be needed per input transfer. But with this AXI reader, we cannot provide backpressure (without a FIFO that is, of course)
    assert#(C: AXI_WIDTH <= sizeof#(T))
    axi_array_burst_reader #(AXI_WIDTH, ADDR_ALIGN, ATO, COUNT_TO: COUNT_TO * NUM_ELEMENTS_PER_VALUE) parent
    parent.aresetn = aresetn

    // export axi interface
    output bool                     arvalid = parent.arvalid
    input  bool                     arready
    output int#(FROM: 0, TO: ATO)   araddr  = parent.araddr
    output int#(FROM: 0, TO: 256)   arlen   = parent.arlen
    output int#(FROM: 0, TO: 8)     arsize  = parent.arsize
    output bool[2]                  arburst = parent.arburst
    output bool[3]                  arprot = parent.arprot
    output bool[4]                  arcache = parent.arcache
    output int#(FROM: 0, TO: 16)    arqos = parent.arqos
    output bool                     arlock = parent.arlock
    output int#(FROM: 0, TO: 16)    arregion = parent.arregion
    input  bool                     rvalid
    output bool                     rready  = parent.rready
    input  bool[AXI_WIDTH]          rdata
    input  bool[2]                  rresp
    input  bool                     rlast
    parent.arready = arready
    parent.rvalid  = rvalid
    parent.rdata   = rdata
    parent.rresp   = rresp
    parent.rlast   = rlast

    output bool may_request_new_burst = parent.may_request_new_burst
    action request_new_burst'0 : int#(FROM: 0, TO: ATO) start_addr, int#(FROM: 1, TO: COUNT_TO) count {
        parent.request_new_burst(start_addr, count * NUM_ELEMENTS_PER_VALUE)
    }

    input bool is_ready_to_receive_lots_of_data
    parent.is_ready_to_receive_lots_of_data = is_ready_to_receive_lots_of_data

    trigger value_valid: T value, bool last

    state bool[ELEMENT_BITWIDTH][NUM_ELEMENTS_PER_VALUE-1] stored_elements
    state int#(FROM: 0, TO: NUM_ELEMENTS_PER_VALUE) cur_element_store_align
    when parent.element_packet_valid : bool[ELEMENT_BITWIDTH][NUM_PARALLEL_ELEMENTS] elements, int#(FROM: 0, TO: NUM_PARALLEL_ELEMENTS) chunk_offset, int#(FROM: 0, TO: NUM_PARALLEL_ELEMENTS+1) chunk_length, bool last {
        bool[ELEMENT_BITWIDTH][NUM_ELEMENTS_PER_VALUE] elements_extended
        elements_extended[:NUM_PARALLEL_ELEMENTS] = elements
        bool[ELEMENT_BITWIDTH][NUM_ELEMENTS_PER_VALUE] rotated_elements = RotateRight(elements_extended, (cur_element_store_align - chunk_offset) % NUM_ELEMENTS_PER_VALUE)
        bool[NUM_ELEMENTS_PER_VALUE] rotated_strobe = MakeStrobe(cur_element_store_align, chunk_length)

        int end_of_element = cur_element_store_align + chunk_length

        when end_of_element >= NUM_ELEMENTS_PER_VALUE {
            bool[sizeof#(T)] resulting_value_bits
            gen int MUXES_START_FROM = NUM_ELEMENTS_PER_VALUE - NUM_PARALLEL_ELEMENTS
            for int ELEM_I in 0..NUM_ELEMENTS_PER_VALUE {
                if ELEM_I < MUXES_START_FROM {
                    resulting_value_bits[ELEM_I * ELEMENT_BITWIDTH +: ELEMENT_BITWIDTH] = stored_elements[ELEM_I]
                } else if ELEM_I == NUM_ELEMENTS_PER_VALUE - 1 {
                    resulting_value_bits[ELEM_I * ELEMENT_BITWIDTH +: ELEMENT_BITWIDTH] = rotated_elements[ELEM_I]
                } else {
                    when cur_element_store_align > ELEM_I {
                        resulting_value_bits[ELEM_I * ELEMENT_BITWIDTH +: ELEMENT_BITWIDTH] = stored_elements[ELEM_I]
                    } else {
                        resulting_value_bits[ELEM_I * ELEMENT_BITWIDTH +: ELEMENT_BITWIDTH] = rotated_elements[ELEM_I]
                    }
                }
            }
            value_valid(transmute_from_bits(resulting_value_bits), last)
        }
        cur_element_store_align = end_of_element % NUM_ELEMENTS_PER_VALUE
        for int ELEM_I in 0..NUM_ELEMENTS_PER_VALUE-1 {
            when rotated_strobe[ELEM_I] {
                stored_elements[ELEM_I] = rotated_elements[ELEM_I]
            }
        }
    }

    when !aresetn {
        cur_element_store_align = 0
    }
}

/// A Bursting AXI Memory writer. Because 
module axi_array_burst_writer#(int AXI_WIDTH, int ADDR_ALIGN) {
    domain aclk
    input bool aresetn'0

    gen int AXI_WIDTH_BYTES = AXI_WIDTH / 8
    gen int AxSIZE = clog2#(V: AXI_WIDTH_BYTES)

    /// Check AXI_WIDTH is a power of two
    assert#(C: pow2#(E: AxSIZE) * 8 == AXI_WIDTH)
    /// AXI standard supported AXI_WIDTHs: 8 - 1024
    assert#(C: (AxSIZE >= 0) & (AxSIZE < 8))

    /// For XRT: Supported AXI_WIDTH ranges from 32-512
    assert#(C: (AXI_WIDTH == 32) | (AXI_WIDTH == 64) | (AXI_WIDTH == 128) | (AXI_WIDTH == 256) | (AXI_WIDTH == 512))

    gen int ADDR_WIDTH = 64
    gen int ATO = pow2#(E: ADDR_WIDTH)

    gen int MAX_AXI_ALIGNMENT = pow2#(E: 12) // 4kb page size, a burst cannot cross a 4K boundary
    gen int MAX_BURST = MAX_AXI_ALIGNMENT / AXI_WIDTH_BYTES

    if MAX_BURST > 256 { // Limited to 256 for BURST_INCR - AXI4. (16 if AXI3, but we only support AXI4)
        MAX_BURST = 256
    }

    gen int MAX_CHUNKS_IN_FLIGHT = MAX_BURST + 64 // 64 cycles is the estimated max DDR latency, and we need MAX_BURST capacity 

    gen int ELEMENT_BITWIDTH = ADDR_ALIGN * 8
    /// The alignment is a power of two
    assert#(C: pow2#(E: clog2#(V: ADDR_ALIGN)) == ADDR_ALIGN)
    gen int NUM_PARALLEL_ELEMENTS = AXI_WIDTH / ELEMENT_BITWIDTH
    assert#(C: AXI_WIDTH % ELEMENT_BITWIDTH == 0)

    output bool                     awvalid'0
    input  bool                     awready'0
    output int#(FROM: 0, TO: ATO)   awaddr'0
    output int#(FROM: 0, TO: 256)   awlen'0
    output int#(FROM: 0, TO: 8)     awsize  = clog2#(V: AXI_WIDTH / 8)
    output bool[2]                  awburst'0 = 2'b01 // BURST
    output bool[3]                  awprot'0 = 3'b000 // Unprivileged, Secure, Data Access
    output bool[4]                  awcache'0 = 4'b0010 // Not bufferable, but can be broken up (into 128-bit, or other)
    output int#(FROM: 0, TO: 16)    awqos'0 = 0 // Lowest priority
    output bool                     awlock'0 = false // NORMAL - No atomics
    output int#(FROM: 0, TO: 16)    awregion'0 = 0 // Region 0
    output bool                     wvalid'0
    input  bool                     wready'0
    output bool[AXI_WIDTH]          wdata'0
    output bool[AXI_WIDTH / 8]      wstrb'0
    output bool                     wlast'0
    input  bool                     bvalid'0
    output bool                     bready'0

    state int cur_wr_elem_addr
    action set_burst_start_addr : int #(FROM: 0, TO: ATO) start_addr {
        cur_wr_elem_addr = start_addr / ELEMENT_BYTE_SIZE
    }

    int cur_elem_chunk, int addr_in_chunk_align = BitwiseIntSplit#(LOWER_BITS: clog2#(V: NUM_PARALLEL_ELEMENTS))(cur_wr_elem_addr)


    gen int FIFO_DEPTH = 500
    state ElemT[NUM_PARALLEL_ELEMENTS][FIFO_DEPTH] fifo_buffer
    state int#(FROM: 0, TO: FIFO_DEPTH * NUM_PARALLEL_ELEMENTS) fifo_write_addr
    int fifo_write_addr_row, int fifo_write_align = BitwiseIntSplit#(LOWER_BITS: clog2#(V: NUM_PARALLEL_ELEMENTS))(fifo_write_addr)
    state int#(FROM: 0, TO: FIFO_DEPTH) fifo_read_addr

    gen int MAY_WRITE_LATENCY = 500

    /// `true` if 
    state bool write_addr_set

    output bool may_write'-MAY_WRITE_LATENCY
    action write'0:
        ElemT[NUM_PARALLEL_ELEMENTS] chunk'0,
        int#(FROM: 0, TO: NUM_PARALLEL_ELEMENTS) chunk_offset'0,
        int#(FROM: 0, TO: NUM_PARALLEL_ELEMENTS+1) chunk_length'0,
        bool last'0 {

        ElemT[NUM_PARALLEL_ELEMENTS] rotated_chunk = RotateRight(chunk, (chunk_offset - fifo_write_align) % NUM_PARALLEL_ELEMENTS) // Most expensive line in the whole writer!
        bool[NUM_PARALLEL_ELEMENTS] write_strobe = MakeStrobe(fifo_write_align, chunk_length)
        
        int new_fifo_write_addr = (fifo_write_addr + chunk_length) % (FIFO_DEPTH * NUM_PARALLEL_ELEMENTS)
        when last {

        } else {
            fifo_write_addr = new_fifo_write_addr
        }
    }
}

module test_burst_reader {
    axi_array_burst_reader #(AXI_WIDTH: 64, ADDR_ALIGN: 2, COUNT_TO: pow2#(E: 16), ATO: pow2#(E: 64)) reader
    //axi_array_burst_reader #(AXI_WIDTH: 512, ADDR_ALIGN: 4, COUNT_TO: pow2#(E: 16), ATO: pow2#(E: 64)) fullFatReader
    //axi_realigning_burst_reader #(T: type float[17], AXI_WIDTH: 512, ADDR_ALIGN: 4, COUNT_TO: pow2#(E: 16), ATO: pow2#(E: 64)) bigSingleObjectReader
    //axi_array_burst_reader #(AXI_WIDTH: 512, ADDR_ALIGN: 4, COUNT_TO: pow2#(E: 16), ATO: pow2#(E: 64)) unalignedBigSingleObjectReader
    axi_realigning_burst_reader #(T: type bool[32][17], AXI_WIDTH: 512, ADDR_ALIGN: 4, COUNT_TO: pow2#(E: 16), ATO: pow2#(E: 64)) unalignedBigSingleObjectReader
    axi_realigning_burst_reader #(T: type bool[32][16], AXI_WIDTH: 512, ADDR_ALIGN: 64, COUNT_TO: pow2#(E: 16), ATO: pow2#(E: 64)) alignedBigSingleObjectReader
    //axi_array_burst_reader #(AXI_WIDTH: 512, ADDR_ALIGN: 64, COUNT_TO: pow2#(E: 16), ATO: pow2#(E: 64)) alignedBigSingleObjectReader
    //axi_array_burst_writer #(AXI_WIDTH: 512, ADDR_ALIGN: 4) fullFatWriter
    
}
