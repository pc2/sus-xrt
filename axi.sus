

/// CTRL REGS is 0x000000
/// Input regs start at 0x000010 and increment 0X000008 every time
/// Output regs start at end of input regs
///
/// XRT imposes a 64K (16bit) address range limitation. 
/// See https://docs.amd.com/r/2023.2-English/ug1393-vitis-application-acceleration/Kernel-Interface-Requirements
///
/// It also appears that ADDR_WIDTH must be >= 12, because the address mapping requires blocks of size 4096
module axi_ctrl_slave #(int NUM_INPUT_REGS, int NUM_OUTPUT_REGS, int ADDR_WIDTH, int AXI_WIDTH) {
    domain aclk
    input bool aresetn

    gen int DATA_STARTS_AT_ADDR = 16 // 0x010
    gen int REG_STRIDE = AXI_WIDTH / 8
    gen int CTRL_REG = 0
    gen int FIRST_REG = DATA_STARTS_AT_ADDR / REG_STRIDE
    assert#(C: DATA_STARTS_AT_ADDR % REG_STRIDE == 0)
    gen int ATO = pow2#(E: ADDR_WIDTH)
    assert#(C: ADDR_WIDTH >= 12)
    assert#(C: ADDR_WIDTH <= 16)
    // Max number of regs
    assert#(C: (FIRST_REG + NUM_INPUT_REGS + NUM_OUTPUT_REGS) * REG_STRIDE <= pow2#(E: ADDR_WIDTH))
    gen bool[2] RESP_OKAY = [false, false]
    gen bool[2] RESP_SLVERR = [false, true]

    // AXI signals
    input int#(FROM: 0, TO: ATO) awaddr
    input bool awvalid
    output bool awready = false
    input bool[AXI_WIDTH] wdata
    input bool[AXI_WIDTH / 8] wstrb
    input bool wvalid
    output bool wready = false
    output bool[2] bresp
    output bool bvalid = false
    input bool bready
    input int#(FROM: 0, TO: ATO) araddr
    input bool arvalid
    output bool arready = false
    output bool[AXI_WIDTH] rdata
    output bool[2] rresp
    output bool rvalid = false
    input bool rready


    state bool[32][NUM_OUTPUT_REGS] stored_output_regs
    output state bool[32][NUM_INPUT_REGS] input_regs
    trigger start

    // control register bits
    state bool reg_ctrl_ap_idle
    state bool reg_ctrl_ap_done
    bool reg_ctrl_ap_ready = reg_ctrl_ap_done    // copy ap_done because there's no pausing
    state bool reg_ctrl_ap_start

    // Write transaction
    state int stored_addr
    state bool stored_addr_valid
    state bool[2] last_bresp
    state bool last_werr_valid
    
    awready = !stored_addr_valid & aresetn // Force low on reset
    wready = stored_addr_valid & !last_werr_valid // Already low by reset
    bvalid = last_werr_valid
    bresp = last_bresp

    when awready & awvalid {
        stored_addr_valid = true
        stored_addr = awaddr / REG_STRIDE
    }
    when wready & wvalid {
        stored_addr_valid = false
        last_werr_valid = true

        last_bresp = RESP_SLVERR
        when stored_addr == CTRL_REG {
            when wstrb[0] & wdata[0] {
                reg_ctrl_ap_start = true
                reg_ctrl_ap_idle = false
                start()
            }
            last_bresp = RESP_OKAY
        }
        // Data Write
        when (stored_addr >= FIRST_REG) & (stored_addr < FIRST_REG + NUM_INPUT_REGS) {
            int write_idx = unsafe_int_cast#(FROM: FIRST_REG, TO: FIRST_REG + NUM_INPUT_REGS)(stored_addr) - FIRST_REG
            for int strbi in 0..4 {
                when wstrb[strbi] {
                    input_regs[write_idx][strbi*8 +: 8] = wdata[strbi*8 +: 8]
                }
            }
            last_bresp = RESP_OKAY
        }
    }
    when bready & bvalid {
        last_werr_valid = false
    }

    // Read transaction
    state bool last_rdata_valid
    state bool[32] last_rdata
    rdata = last_rdata
    state bool[2] last_rresp
    rresp = last_rresp

    bool[32][NUM_INPUT_REGS + NUM_OUTPUT_REGS] regs_read_multiplexer
    regs_read_multiplexer[:NUM_INPUT_REGS] = input_regs
    regs_read_multiplexer[NUM_INPUT_REGS:] = stored_output_regs

    arready = !last_rdata_valid & aresetn // Force low on reset
    rvalid = last_rdata_valid // Already low by reset

    when arready & arvalid {
        last_rdata_valid = true
        
        // Control Read
        last_rresp = RESP_SLVERR
        int read_addr = araddr / REG_STRIDE
        when read_addr == CTRL_REG {
            last_rdata[0] = reg_ctrl_ap_start
            last_rdata[1] = reg_ctrl_ap_done
            last_rdata[2] = reg_ctrl_ap_idle
            last_rdata[3] = reg_ctrl_ap_ready
            last_rdata[4:] = Repeat(false)
            when reg_ctrl_ap_done {
                reg_ctrl_ap_idle = true
            }
            reg_ctrl_ap_done = false // clear on read
            last_rresp = RESP_OKAY
        }
        // Data Read
        when (read_addr >= FIRST_REG) & (read_addr < FIRST_REG + NUM_INPUT_REGS + NUM_OUTPUT_REGS) {
            int read_idx = unsafe_int_cast#(FROM: FIRST_REG, TO: FIRST_REG + NUM_INPUT_REGS + NUM_OUTPUT_REGS)(read_addr) - FIRST_REG
            last_rdata = regs_read_multiplexer[read_idx]
            last_rresp = RESP_OKAY
        }
    }
    when rready & rvalid {
        last_rdata_valid = false
    }

    action finish : bool[32][NUM_OUTPUT_REGS] output_regs {
        stored_output_regs = output_regs
        reg_ctrl_ap_done = true
        reg_ctrl_ap_start = false
        reg_ctrl_ap_idle = false
    }

    when !aresetn {
        stored_addr_valid = false
        last_werr_valid = false

        last_rdata_valid = false

        reg_ctrl_ap_idle = true
        reg_ctrl_ap_start = false
        reg_ctrl_ap_done = false

        input_regs = Repeat(Repeat(false))
        stored_output_regs = Repeat(Repeat(false))
    }
}


module axi_ctrl_slave_example {
    domain aclk
    input bool aresetn

    gen int ADDR_WIDTH = 12
    gen int ATO = pow2#(E: ADDR_WIDTH)
    gen int DATA_WIDTH = 32

    axi_ctrl_slave #(NUM_INPUT_REGS: 2, NUM_OUTPUT_REGS: 500, ADDR_WIDTH) axi_control
    axi_control.aresetn = aresetn

    // Export AXI4-Lite interface
    input  int#(FROM: 0, TO: ATO) s_axi_control_awaddr
    input  bool                   s_axi_control_awvalid
    output bool                   s_axi_control_awready = axi_control.awready
    input  bool[DATA_WIDTH]       s_axi_control_wdata
    input  bool[DATA_WIDTH / 8]   s_axi_control_wstrb
    input  bool                   s_axi_control_wvalid
    output bool                   s_axi_control_wready  = axi_control.wready
    output bool[2]                s_axi_control_bresp   = axi_control.bresp
    output bool                   s_axi_control_bvalid  = axi_control.bvalid
    input  bool                   s_axi_control_bready
    input  int#(FROM: 0, TO: ATO) s_axi_control_araddr
    input  bool                   s_axi_control_arvalid
    output bool                   s_axi_control_arready = axi_control.arready
    output bool[DATA_WIDTH]       s_axi_control_rdata   = axi_control.rdata
    output bool[2]                s_axi_control_rresp   = axi_control.rresp
    output bool                   s_axi_control_rvalid  = axi_control.rvalid
    input  bool                   s_axi_control_rready
    axi_control.awaddr  = s_axi_control_awaddr
    axi_control.awvalid = s_axi_control_awvalid
    axi_control.wdata   = s_axi_control_wdata
    axi_control.wstrb   = s_axi_control_wstrb
    axi_control.wvalid  = s_axi_control_wvalid
    axi_control.bready  = s_axi_control_bready
    axi_control.araddr  = s_axi_control_araddr
    axi_control.arvalid = s_axi_control_arvalid
    axi_control.rready  = s_axi_control_rready
    
    output state bool[DATA_WIDTH] outstream_tdata
    output state bool             outstream_tvalid
    input  bool                   outstream_tready

    state int#(FROM: 0, TO: pow2#(E: 32)) wait_count

    /*when wait_count != 0 {
        when wait_count == 1 {
            axi_control.finish([UIntToBits(20000)])
        }
        wait_count = unsafe_int_cast#(FROM: 1, TO: pow2#(E: 32))(wait_count) - 1
    }*/
    
    //state bool[32] bits_to_transmit

    state bool[32][500] writes_shift_reg

    when s_axi_control_awvalid & s_axi_control_awready {
        bool[32] new_bits = UIntToBits(s_axi_control_awaddr)

        for int i in 1..500 {
            writes_shift_reg[i] = writes_shift_reg[i-1]
        }
        writes_shift_reg[0] = new_bits
    }
    

    // Actual logic
    when axi_control.start {
        int a = BitsToUInt(axi_control.input_regs[0])
        int b = BitsToUInt(axi_control.input_regs[1])

        int c = (a + b) % pow2#(E: 32)

        //wait_count = a

        
        axi_control.finish(writes_shift_reg)

        outstream_tvalid = true
        outstream_tdata = UIntToBits(c)
    }

    when outstream_tready & outstream_tvalid {
        outstream_tvalid = false
    }

    when !aresetn {
        outstream_tvalid = false 
        //bits_to_transmit = Repeat(true)
    }
}


module axi_memory_reader #(T) {
    domain aclk

    input bool aresetn'0

    gen int ADDR_WIDTH = 64
    gen int ATO = pow2#(E: ADDR_WIDTH)
    gen int AXI_WIDTH = 32
    gen int MAX_ARLEN = 255

    gen int NUM_TRANSFERS
    if sizeof#(T) <= AXI_WIDTH {
        NUM_TRANSFERS = 1
        assert#(C: sizeof#(T) % 8 == 0)
    } else {
        // Actually this code is fine even if it's not a multiple
        // assert#(C: sizeof#(T) % AXI_WIDTH == 0) // sizeof#(T) must be a multiple of AXI_WIDTH
        assert#(C: sizeof#(T) <= MAX_ARLEN * AXI_WIDTH) // T is too big!
        NUM_TRANSFERS = sizeof#(T) / AXI_WIDTH
        assert#(C: NUM_TRANSFERS < MAX_ARLEN) // T is too big!
        assert#(C: sizeof#(T) % AXI_WIDTH == 0)
    }
    
    // axi mm master
    // write channels - tie off, never ready/valid
    output bool                     awvalid'0
    input  bool                     awready'0
    output int#(FROM: 0, TO: ATO)   awaddr'0
    output int#(FROM: 0, TO: 256)   awlen'0
    output bool                     wvalid'0
    input  bool                     wready'0
    output bool[AXI_WIDTH]          wdata'0
    output bool[AXI_WIDTH / 8]      wstrb'0
    output bool                     wlast'0
    input  bool                     bvalid'0
    output bool                     bready'0

    // No writer
    awvalid = false
    awaddr = 0
    awlen = 0
    wvalid = false
    wdata = Repeat(false)
    wstrb = Repeat(false)
    wlast = false
    bready = false

    /*state bool[sizeof#(T)] writing_data
    state bool writing_data_valid
    wvalid = writing_data_valid

    if sizeof#(T) <= AXI_WIDTH {
        wdata = writing_data
        if sizeof#(T) == 8 {
            wstrb = 4'b0001
            wdata[0:8] = writing_data
            wdata[8:32] = Repeat(false)
        } else if sizeof#(T) == 16 {
            wstrb = 4'b0011
            wdata[0:16] = writing_data
            wdata[16:32] = Repeat(false)
        } else if sizeof#(T) == 24 {
            wstrb = 4'b0111
            wdata[0:24] = writing_data
            wdata[24:32] = Repeat(false)
        } else if sizeof#(T) == 32 {
            wstrb = 4'b1111
            wdata = writing_data
        } else {
            assert#(C: false)
        }
        when wvalid & wready {
            writing_data_valid = false // fire!
        }
    } else {
        state int#(FROM: 0, TO: NUM_TRANSFERS) cur_data_chunk

        bool[AXI_WIDTH][NUM_TRANSFERS] parts
        for int i in 0..NUM_TRANSFERS {
            parts[i] = writing_data[i * AXI_WIDTH +: AXI_WIDTH]
        }

        wdata = parts[cur_data_chunk]

        when awvalid & awready {
            cur_data_chunk = 0
        }
    }

    action write : int#(FROM: 0, TO: ATO) wr_addr, T wr_data -> bool write_success {
        awlen = NUM_TRANSFERS - 1 // 0 is used for length '1', 1 for '2', etc. I think this is because a len-0 transfer makes no sense? 
        awaddr = wr_addr
        awvalid = !writing_data_valid
        write_success = awready

        when awvalid & awready {
            writing_data = transmute_to_bits(wr_data)
            writing_data_valid = true
        }
        

    } else {
        awvalid = false
    }

    when !aresetn {
        writing_data_valid = false
    }*/



    // read channel
    output bool                     arvalid'0
    input  bool                     arready'0
    output int#(FROM: 0, TO: ATO)   araddr'0
    output int#(FROM: 0, TO: 256)   arlen'0
    input  bool                     rvalid'0
    output bool                     rready'0
    input  bool[AXI_WIDTH]          rdata'0
    input  bool                     rlast'0



    // control signals
    // Returns "true" if the request was 
    action request : int#(FROM: 0, TO: ATO) addr -> bool fire {
        arvalid = true
        araddr = addr
        arlen = NUM_TRANSFERS - 1 // 0 is used for length '1', 1 for '2', etc. I think this is because a len-0 transfer makes no sense? 
        fire = arready
    } else {
        arvalid = false
    }

    bool do_read
    bool do_read_was_valid
    bool[sizeof#(T)] do_read_data

    if sizeof#(T) <= AXI_WIDTH {
        // rlast should be true
        rready = do_read
        do_read_was_valid = rvalid
        do_read_data = rdata[:sizeof#(T)]
    } else if sizeof#(T) > AXI_WIDTH {
        state int#(FROM: 0, TO: NUM_TRANSFERS) stored_part_idx
        state bool[AXI_WIDTH][NUM_TRANSFERS - 1] stored_parts

        rready = false
        when stored_part_idx < NUM_TRANSFERS - 1 {
            do_read_was_valid = false
            rready = true
            when rvalid {
                int idx = unsafe_int_cast#(FROM: 0, TO: NUM_TRANSFERS - 1)(stored_part_idx)
                stored_parts[idx] = rdata
                stored_part_idx = idx + 1
            }
        } else {
            do_read_was_valid = rvalid
            rready = do_read
            when rready & rvalid {
                // rlast should be true
                stored_part_idx = 0
                for int i in 0..NUM_TRANSFERS-1 {
                    do_read_data[i * AXI_WIDTH +: AXI_WIDTH] = stored_parts[i]
                }
                do_read_data[(NUM_TRANSFERS - 1) * AXI_WIDTH +: AXI_WIDTH] = rdata
            }
        }
        when !aresetn {
            stored_part_idx = 0
        }
    }

    action read'0 : -> bool read_valid'0, T data'0 {
        do_read = true
        read_valid = do_read_was_valid
        when do_read_was_valid {
            data = transmute_from_bits(do_read_data)
        }
    } else {
        do_read = false
    }
}


module test_axi_memory_reader {
    axi_memory_reader#(T: type float) read_A
    axi_memory_reader#(T: type float[4]) read_B
    //axi_memory_reader#(T: type int#(FROM: 0, TO: 3)) read_C
}

module combined_axi_ctrl_plus_reader {
    domain aclk
    input bool aresetn

    gen int ADDR_WIDTH = 12
    gen int ATO = pow2#(E: ADDR_WIDTH)
    gen int MTO = pow2#(E: 64)
    gen int AXI_WIDTH = 32

    axi_ctrl_slave #(NUM_INPUT_REGS: 4, NUM_OUTPUT_REGS: 1, ADDR_WIDTH) axi_control
    axi_control.aresetn = aresetn

    // Export AXI4-Lite interface
    input  int#(FROM: 0, TO: ATO) s_axi_control_awaddr
    input  bool                   s_axi_control_awvalid
    output bool                   s_axi_control_awready = axi_control.awready
    input  bool[AXI_WIDTH]        s_axi_control_wdata
    input  bool[AXI_WIDTH / 8]    s_axi_control_wstrb
    input  bool                   s_axi_control_wvalid
    output bool                   s_axi_control_wready  = axi_control.wready
    output bool[2]                s_axi_control_bresp   = axi_control.bresp
    output bool                   s_axi_control_bvalid  = axi_control.bvalid
    input  bool                   s_axi_control_bready
    input  int#(FROM: 0, TO: ATO) s_axi_control_araddr
    input  bool                   s_axi_control_arvalid
    output bool                   s_axi_control_arready = axi_control.arready
    output bool[AXI_WIDTH]        s_axi_control_rdata   = axi_control.rdata
    output bool[2]                s_axi_control_rresp   = axi_control.rresp
    output bool                   s_axi_control_rvalid  = axi_control.rvalid
    input  bool                   s_axi_control_rready
    axi_control.awaddr  =         s_axi_control_awaddr
    axi_control.awvalid =         s_axi_control_awvalid
    axi_control.wdata   =         s_axi_control_wdata
    axi_control.wstrb   =         s_axi_control_wstrb
    axi_control.wvalid  =         s_axi_control_wvalid
    axi_control.bready  =         s_axi_control_bready
    axi_control.araddr  =         s_axi_control_araddr
    axi_control.arvalid =         s_axi_control_arvalid
    axi_control.rready  =         s_axi_control_rready

    axi_memory_reader#(T: type int#(FROM: 0, TO: pow2#(E: 32))) reader
    reader.aresetn = aresetn


    output bool                     m_axi_awvalid = reader.awvalid
    input  bool                     m_axi_awready
    output int#(FROM: 0, TO: MTO)   m_axi_awaddr = reader.awaddr
    output int#(FROM: 0, TO: 256)   m_axi_awlen = reader.awlen
    output bool                     m_axi_wvalid = reader.wvalid
    input  bool                     m_axi_wready
    output bool[AXI_WIDTH]          m_axi_wdata = reader.wdata
    output bool[AXI_WIDTH / 8]      m_axi_wstrb = reader.wstrb
    output bool                     m_axi_wlast = reader.wlast
    input  bool                     m_axi_bvalid
    output bool                     m_axi_bready = reader.bready
    reader.bvalid =                 m_axi_bvalid
    reader.wready =                 m_axi_wready
    reader.awready =                m_axi_awready
    output bool                     m_axi_arvalid = reader.arvalid
    input  bool                     m_axi_arready
    output int#(FROM: 0, TO: MTO)   m_axi_araddr = reader.araddr
    output int#(FROM: 0, TO: 256)   m_axi_arlen = reader.arlen
    input  bool                     m_axi_rvalid
    output bool                     m_axi_rready = reader.rready
    input  bool[AXI_WIDTH]          m_axi_rdata
    input  bool                     m_axi_rlast
    reader.arready =                m_axi_arready
    reader.rvalid =                 m_axi_rvalid
    reader.rdata =                  m_axi_rdata
    reader.rlast =                  m_axi_rlast

    /// Output axi
    output state bool[32]         outstream_tdata
    output state bool             outstream_tvalid
    input  bool                   outstream_tready

    // Actual logic

    gen int STM_IDLE  = 0
    gen int STM_GET_A = 1
    gen int STM_GET_B = 2

    state int addr_state

    state int data_state

    when addr_state == STM_GET_A {
        bool[64] addr_a_bits
        addr_a_bits[:32] = axi_control.input_regs[0]
        addr_a_bits[32:] = axi_control.input_regs[1]
        when reader.request(BitsToUInt(addr_a_bits)) {
            addr_state = STM_GET_B
        }
    } else when addr_state == STM_GET_B {
        bool[64] addr_b_bits
        addr_b_bits[:32] = axi_control.input_regs[2]
        addr_b_bits[32:] = axi_control.input_regs[3]
        when reader.request(BitsToUInt(addr_b_bits)) {
            addr_state = STM_IDLE
        }
    }

    state int stored_a
    when data_state == STM_GET_A {
        bool success, int data = reader.read()
        when success {
            stored_a = data
            data_state = STM_GET_B
        }
    } else when data_state == STM_GET_B {
        bool success, int b = reader.read()
        when success {
            int c = (stored_a + b) % pow2#(E: 32)
            bool[32] c_as_bits = UIntToBits(c)
            axi_control.finish([c_as_bits])
            data_state = STM_IDLE

            outstream_tdata = c_as_bits
            outstream_tvalid = true
        }
    }

    when outstream_tvalid & outstream_tready {
        outstream_tvalid = false
    }

    when axi_control.start {
        addr_state = STM_GET_A
        data_state = STM_GET_A
    }

    when !aresetn {
        addr_state = STM_IDLE
        data_state = STM_IDLE
        outstream_tvalid = false
    }
}
