
module axis_master_fifo#(T, int DEPTH, int MAY_PUSH_LATENCY) {
    input bool aresetn'0

    input bool tready'0
    output bool tvalid'0
    output bool[sizeof#(T)] tdata'0

    /// Basically the same as a FWFT XPM FIFO, just that we can't yet instantiate that one without an extra SV file. (#131)
    state T[DEPTH] memory
    state int#(FROM: 0, TO: DEPTH) wr_addr
    state int#(FROM: 0, TO: DEPTH) rd_addr
    
    bool do_read = !tvalid | tready & tvalid

    gen int NUM_PIPELINE_STAGES
    if DEPTH <= 64 {
        NUM_PIPELINE_STAGES = 1
    } else {
        NUM_PIPELINE_STAGES = 2
    }
    state T[NUM_PIPELINE_STAGES] memory_read_pipeline_stages
    state bool[NUM_PIPELINE_STAGES] memory_read_pipeline_stages_valids
    when do_read {
        for int i in 1..NUM_PIPELINE_STAGES {
            memory_read_pipeline_stages[i] = memory_read_pipeline_stages[i-1]
            memory_read_pipeline_stages_valids[i] = memory_read_pipeline_stages_valids[i-1]
        }
        bool read_from_mem_is_valid = rd_addr != wr_addr
        memory_read_pipeline_stages_valids[0] = read_from_mem_is_valid
        when read_from_mem_is_valid {
            memory_read_pipeline_stages[0] = memory[rd_addr]
            rd_addr = (rd_addr + 1) % DEPTH
        }
    }

    tdata = transmute_to_bits(memory_read_pipeline_stages[NUM_PIPELINE_STAGES - 1])
    tvalid = memory_read_pipeline_stages_valids[NUM_PIPELINE_STAGES - 1]

    int free_space = (rd_addr - wr_addr - 1) % DEPTH

    output bool may_push'-MAY_PUSH_LATENCY
    may_push = LatencyOffset#(OFFSET: -MAY_PUSH_LATENCY)(free_space >= MAY_PUSH_LATENCY)
    action push'0: T data'0 {
        memory[wr_addr] = data
        wr_addr = (wr_addr + 1) % DEPTH
    }

    when !aresetn {
        wr_addr = 0
        rd_addr = 0

        for int i in 0..NUM_PIPELINE_STAGES {
            memory_read_pipeline_stages_valids[i] = false
        }
    }
}

/// CTRL REGS is 0x000000
/// Input regs start at 0x000010 and increment 0X000008 every time
/// Output regs start at end of input regs
///
/// XRT imposes a 64K (16bit) address range limitation. 
/// See https://docs.amd.com/r/2023.2-English/ug1393-vitis-application-acceleration/Kernel-Interface-Requirements
///
/// It also appears that ADDR_WIDTH must be >= 12, because the address mapping requires blocks of size 4096
module axi_ctrl_slave #(int NUM_INPUT_REGS, int NUM_OUTPUT_REGS, int ADDR_WIDTH, int AXI_WIDTH) {
    domain aclk
    input bool aresetn

    gen int DATA_STARTS_AT_ADDR = 16 // 0x010
    gen int REG_STRIDE = AXI_WIDTH / 8
    gen int CTRL_REG = 0
    gen int FIRST_REG = DATA_STARTS_AT_ADDR / REG_STRIDE
    assert#(C: DATA_STARTS_AT_ADDR % REG_STRIDE == 0)
    gen int ATO = pow2#(E: ADDR_WIDTH)
    assert#(C: ADDR_WIDTH >= 12)
    assert#(C: ADDR_WIDTH <= 16)
    // Max number of regs
    assert#(C: (FIRST_REG + NUM_INPUT_REGS + NUM_OUTPUT_REGS) * REG_STRIDE <= pow2#(E: ADDR_WIDTH))
    gen bool[2] RESP_OKAY = [false, false]
    gen bool[2] RESP_SLVERR = [false, true]

    // AXI signals
    input int#(FROM: 0, TO: ATO) awaddr
    input bool awvalid
    output bool awready = false
    input bool[AXI_WIDTH] wdata
    input bool[AXI_WIDTH / 8] wstrb
    input bool wvalid
    output bool wready = false
    output bool[2] bresp
    output bool bvalid = false
    input bool bready
    input int#(FROM: 0, TO: ATO) araddr
    input bool arvalid
    output bool arready = false
    output bool[AXI_WIDTH] rdata
    output bool[2] rresp
    output bool rvalid = false
    input bool rready


    state bool[32][NUM_OUTPUT_REGS] stored_output_regs
    output state bool[32][NUM_INPUT_REGS] input_regs
    trigger start

    // control register bits
    state bool reg_ctrl_ap_idle
    state bool reg_ctrl_ap_done
    bool reg_ctrl_ap_ready = reg_ctrl_ap_done    // copy ap_done because there's no pausing
    state bool reg_ctrl_ap_start

    // Write transaction
    state int stored_addr
    state bool stored_addr_valid
    state bool[2] last_bresp
    state bool last_werr_valid
    
    awready = !stored_addr_valid & aresetn // Force low on reset
    wready = stored_addr_valid & !last_werr_valid // Already low by reset
    bvalid = last_werr_valid
    bresp = last_bresp

    when awready & awvalid {
        stored_addr_valid = true
        stored_addr = awaddr / REG_STRIDE
    }
    when wready & wvalid {
        stored_addr_valid = false
        last_werr_valid = true

        last_bresp = RESP_SLVERR
        when stored_addr == CTRL_REG {
            when wstrb[0] & wdata[0] {
                reg_ctrl_ap_start = true
                reg_ctrl_ap_idle = false
                start()
            }
            last_bresp = RESP_OKAY
        }
        // Data Write
        when (stored_addr >= FIRST_REG) & (stored_addr < FIRST_REG + NUM_INPUT_REGS) {
            int write_idx = unsafe_int_cast#(FROM: FIRST_REG, TO: FIRST_REG + NUM_INPUT_REGS)(stored_addr) - FIRST_REG
            for int strbi in 0..4 {
                when wstrb[strbi] {
                    input_regs[write_idx][strbi*8 +: 8] = wdata[strbi*8 +: 8]
                }
            }
            last_bresp = RESP_OKAY
        }
    }
    when bready & bvalid {
        last_werr_valid = false
    }

    // Read transaction
    state bool last_rdata_valid
    state bool[32] last_rdata
    rdata = last_rdata
    state bool[2] last_rresp
    rresp = last_rresp

    bool[32][NUM_INPUT_REGS + NUM_OUTPUT_REGS] regs_read_multiplexer
    regs_read_multiplexer[:NUM_INPUT_REGS] = input_regs
    regs_read_multiplexer[NUM_INPUT_REGS:] = stored_output_regs

    arready = !last_rdata_valid & aresetn // Force low on reset
    rvalid = last_rdata_valid // Already low by reset

    when arready & arvalid {
        last_rdata_valid = true
        
        // Control Read
        last_rresp = RESP_SLVERR
        int read_addr = araddr / REG_STRIDE
        when read_addr == CTRL_REG {
            last_rdata[0] = reg_ctrl_ap_start
            last_rdata[1] = reg_ctrl_ap_done
            last_rdata[2] = reg_ctrl_ap_idle
            last_rdata[3] = reg_ctrl_ap_ready
            last_rdata[4:] = Repeat(false)
            when reg_ctrl_ap_done {
                reg_ctrl_ap_idle = true
            }
            reg_ctrl_ap_done = false // clear on read
            last_rresp = RESP_OKAY
        }
        // Data Read
        when (read_addr >= FIRST_REG) & (read_addr < FIRST_REG + NUM_INPUT_REGS + NUM_OUTPUT_REGS) {
            int read_idx = unsafe_int_cast#(FROM: FIRST_REG, TO: FIRST_REG + NUM_INPUT_REGS + NUM_OUTPUT_REGS)(read_addr) - FIRST_REG
            last_rdata = regs_read_multiplexer[read_idx]
            last_rresp = RESP_OKAY
        }
    }
    when rready & rvalid {
        last_rdata_valid = false
    }

    action finish : bool[32][NUM_OUTPUT_REGS] output_regs {
        stored_output_regs = output_regs
        reg_ctrl_ap_done = true
        reg_ctrl_ap_start = false
        reg_ctrl_ap_idle = false
    }

    when !aresetn {
        stored_addr_valid = false
        last_werr_valid = false

        last_rdata_valid = false

        reg_ctrl_ap_idle = true
        reg_ctrl_ap_start = false
        reg_ctrl_ap_done = false

        input_regs = Repeat(Repeat(false))
        stored_output_regs = Repeat(Repeat(false))
    }
}


module axi_memory_reader_tie_off {
    domain aclk
    input bool aresetn'0

    gen int ADDR_WIDTH = 64
    gen int ATO = pow2#(E: ADDR_WIDTH)
    gen int AXI_WIDTH = 32

    // axi mm master
    // read channels - tie off, never ready/valid
    output bool                     arvalid'0
    input  bool                     arready'0
    output int#(FROM: 0, TO: ATO)   araddr'0
    output int#(FROM: 0, TO: 256)   arlen'0
    output bool[2]                  arburst'0
    input  bool                     rvalid'0
    output bool                     rready'0
    input  bool[AXI_WIDTH]          rdata'0
    input  bool                     rlast'0

    // Tie off
    arvalid = false
    araddr = 0
    arlen = 0
    arburst = Repeat(false)
    rready = false
}

module axi_memory_writer_tie_off {
    domain aclk
    input bool aresetn'0

    gen int ADDR_WIDTH = 64
    gen int ATO = pow2#(E: ADDR_WIDTH)
    gen int AXI_WIDTH = 32

    // axi mm master
    // write channels - tie off, never ready/valid
    output bool                     awvalid'0
    input  bool                     awready'0
    output int#(FROM: 0, TO: ATO)   awaddr'0
    output int#(FROM: 0, TO: 256)   awlen'0
    output bool[2]                  awburst'0
    output bool                     wvalid'0
    input  bool                     wready'0
    output bool[AXI_WIDTH]          wdata'0
    output bool[AXI_WIDTH / 8]      wstrb'0
    output bool                     wlast'0
    input  bool                     bvalid'0
    output bool                     bready'0

    // Tie off
    awvalid = false
    awaddr = 0
    awlen = 0
    awburst = Repeat(false)
    wvalid = false
    wdata = Repeat(false)
    wstrb = Repeat(false)
    wlast = false
    bready = false
}


module axi_memory_reader #(T) {
    domain aclk
    input bool aresetn'0

    gen int ADDR_WIDTH = 64
    gen int ATO = pow2#(E: ADDR_WIDTH)
    gen int AXI_WIDTH = 32
    gen int MAX_ARLEN = 255

    gen int NUM_TRANSFERS
    if sizeof#(T) <= AXI_WIDTH {
        NUM_TRANSFERS = 1
        assert#(C: sizeof#(T) % 8 == 0)
    } else {
        // Actually this code is fine even if it's not a multiple
        // assert#(C: sizeof#(T) % AXI_WIDTH == 0) // sizeof#(T) must be a multiple of AXI_WIDTH
        assert#(C: sizeof#(T) <= MAX_ARLEN * AXI_WIDTH) // T is too big!
        NUM_TRANSFERS = sizeof#(T) / AXI_WIDTH
        assert#(C: NUM_TRANSFERS < MAX_ARLEN) // T is too big!
        assert#(C: sizeof#(T) % AXI_WIDTH == 0)
    }

    // read channel
    output bool                     arvalid'0
    input  bool                     arready'0
    output int#(FROM: 0, TO: ATO)   araddr'0
    output int#(FROM: 0, TO: 256)   arlen'0
    output bool[2]                  arburst'0
    input  bool                     rvalid'0
    output bool                     rready'0
    input  bool[AXI_WIDTH]          rdata'0
    input  bool                     rlast'0

    // control signals
    // Returns "true" if the request was 
    action request : int#(FROM: 0, TO: ATO) addr -> bool fire {
        arvalid = true
        araddr = addr
        arlen = NUM_TRANSFERS - 1 // 0 is used for length '1', 1 for '2', etc. I think this is because a len-0 transfer makes no sense? 
        arburst = 2'b01 // BURST_INC
        fire = arready
    } else {
        arvalid = false
    }

    bool do_read
    bool do_read_was_valid
    bool[sizeof#(T)] do_read_data

    if sizeof#(T) <= AXI_WIDTH {
        // rlast should be true
        rready = do_read
        do_read_was_valid = rvalid
        do_read_data = rdata[:sizeof#(T)]
    } else if sizeof#(T) > AXI_WIDTH {
        state int#(FROM: 0, TO: NUM_TRANSFERS) stored_part_idx
        state bool[AXI_WIDTH][NUM_TRANSFERS - 1] stored_parts

        rready = false
        when stored_part_idx < NUM_TRANSFERS - 1 {
            do_read_was_valid = false
            rready = true
            when rvalid {
                int idx = unsafe_int_cast#(FROM: 0, TO: NUM_TRANSFERS - 1)(stored_part_idx)
                stored_parts[idx] = rdata
                stored_part_idx = idx + 1
            }
        } else {
            do_read_was_valid = rvalid
            rready = do_read
            when rready & rvalid {
                // rlast should be true
                stored_part_idx = 0
                for int i in 0..NUM_TRANSFERS-1 {
                    do_read_data[i * AXI_WIDTH +: AXI_WIDTH] = stored_parts[i]
                }
                do_read_data[(NUM_TRANSFERS - 1) * AXI_WIDTH +: AXI_WIDTH] = rdata
            }
        }
        when !aresetn {
            stored_part_idx = 0
        }
    }

    action read'0 : -> bool read_valid'0, T data'0 {
        do_read = true
        read_valid = do_read_was_valid
        when do_read_was_valid {
            data = transmute_from_bits(do_read_data)
        }
    } else {
        do_read = false
    }
}

module axi_memory_writer #(T) {
    domain aclk

    input bool aresetn

    gen int ADDR_WIDTH = 64
    gen int ATO = pow2#(E: ADDR_WIDTH)
    gen int AXI_WIDTH = 32
    gen int MAX_ARLEN = 255
    gen int OUTSTANDING_WRITES_CAPACITY = 256

    gen int NUM_TRANSFERS
    if sizeof#(T) <= AXI_WIDTH {
        NUM_TRANSFERS = 1
        assert#(C: sizeof#(T) % 8 == 0)
    } else {
        // Actually this code is fine even if it's not a multiple
        // assert#(C: sizeof#(T) % AXI_WIDTH == 0) // sizeof#(T) must be a multiple of AXI_WIDTH
        assert#(C: sizeof#(T) <= MAX_ARLEN * AXI_WIDTH) // T is too big!
        NUM_TRANSFERS = sizeof#(T) / AXI_WIDTH
        assert#(C: NUM_TRANSFERS < MAX_ARLEN) // T is too big!
        assert#(C: sizeof#(T) % AXI_WIDTH == 0)
    }


    // axi mm master
    // write channels - tie off, never ready/valid
    output bool                     awvalid'0
    input  bool                     awready'0
    output int#(FROM: 0, TO: ATO)   awaddr'0
    output int#(FROM: 0, TO: 256)   awlen'0
    output bool[2]                  awburst'0
    output bool                     wvalid'0
    input  bool                     wready'0
    output bool[AXI_WIDTH]          wdata'0
    output bool[AXI_WIDTH / 8]      wstrb'0
    output bool                     wlast'0
    input  bool                     bvalid'0
    output bool                     bready'0
    // input  bool[2]                  bresp'0 // ignore bresp, we can't handle errors anyway

    // No writer
    /*awvalid = false
    awaddr = 0
    awlen = 0
    wvalid = false
    wdata = Repeat(false)
    wstrb = Repeat(false)
    wlast = false
    bready = false*/

    state bool[sizeof#(T)] writing_data
    state bool writing_data_valid
    wvalid = writing_data_valid
    state int#(FROM: 0, TO: OUTSTANDING_WRITES_CAPACITY) num_outstanding_writes
    /// Used to check that all writes have been committed to memory before proceeding
    bready = num_outstanding_writes != 0

    if sizeof#(T) <= AXI_WIDTH {
        wdata = writing_data
        wlast = true
        if sizeof#(T) == 8 {
            wstrb = 4'b0001
            wdata[0:8] = writing_data
            wdata[8:32] = Repeat(false)
        } else if sizeof#(T) == 16 {
            wstrb = 4'b0011
            wdata[0:16] = writing_data
            wdata[16:32] = Repeat(false)
        } else if sizeof#(T) == 24 {
            wstrb = 4'b0111
            wdata[0:24] = writing_data
            wdata[24:32] = Repeat(false)
        } else if sizeof#(T) == 32 {
            wstrb = 4'b1111
            wdata = writing_data
        } else {
            assert#(C: false)
        }
        when wvalid & wready {
            writing_data_valid = false // fire!
        }
    } else {
        state int#(FROM: 0, TO: NUM_TRANSFERS) cur_data_chunk

        bool[AXI_WIDTH][NUM_TRANSFERS] parts
        for int i in 0..NUM_TRANSFERS {
            parts[i] = writing_data[i * AXI_WIDTH +: AXI_WIDTH]
        }

        wdata = parts[cur_data_chunk]
        wstrb = 4'b1111
        wlast = !(cur_data_chunk < NUM_TRANSFERS - 1)

        when wvalid & wready {
            // fire!
            when !wlast {
                cur_data_chunk = unsafe_int_cast#(FROM: 0, TO: NUM_TRANSFERS - 1)(cur_data_chunk + 1)
            } else {
                writing_data_valid = false
            }
        }

        when awvalid & awready {
            cur_data_chunk = 0
            // writing_data is already written by the write action
        }
    }

    output bool has_outstanding_writes = bready
    action write : int#(FROM: 0, TO: ATO) addr, T data -> bool write_success {
        awlen = NUM_TRANSFERS - 1 // 0 is used for length '1', 1 for '2', etc. I think this is because a len-0 transfer makes no sense? 
        awburst = 2'b01 // BURST_INC
        awaddr = addr
        awvalid = !writing_data_valid & (num_outstanding_writes < OUTSTANDING_WRITES_CAPACITY - 1)
        write_success = awready

        when awvalid & awready {
            writing_data = transmute_to_bits(data)
            writing_data_valid = true
        }
    } else {
        awvalid = false
    }

    when awvalid & awready & !(bvalid & bready) {
        num_outstanding_writes = unsafe_int_cast#(FROM: 0, TO: OUTSTANDING_WRITES_CAPACITY - 1)(num_outstanding_writes) + 1
    } else when bvalid & bready & !(awvalid & awready) {
        num_outstanding_writes = unsafe_int_cast#(FROM: 1, TO: OUTSTANDING_WRITES_CAPACITY)(num_outstanding_writes) - 1
    }

    when !aresetn {
        writing_data_valid = false
        num_outstanding_writes = 0
    }
}
