

module axis_master_fifo_example {
    input bool aresetn

    input bool axis_tready
    output bool axis_tvalid
    output bool[sizeof#(T: type float)] axis_tdata

    axis_master_fifo#(DEPTH: 32) my_fifo
    my_fifo.aresetn = aresetn
    my_fifo.tready = axis_tready
    axis_tvalid = my_fifo.tvalid
    axis_tdata = my_fifo.tdata

    output bool may_push'-10 = my_fifo.may_push
    action push'0 : float data'0 {
        my_fifo.push(data)
    }
}


module axi_ctrl_slave_example {
    domain aclk
    input bool aresetn

    gen int ADDR_WIDTH = 12
    gen int ATO = pow2#(E: ADDR_WIDTH)
    gen int DATA_WIDTH = 32

    axi_ctrl_slave #(NUM_INPUT_REGS: 2, NUM_OUTPUT_REGS: 500, ADDR_WIDTH) ctrl
    ctrl.aresetn = aresetn

    // Export AXI4-Lite interface
    input  int#(FROM: 0, TO: ATO) s_axi_control_awaddr
    input  bool                   s_axi_control_awvalid
    output bool                   s_axi_control_awready = ctrl.awready
    input  bool[DATA_WIDTH]       s_axi_control_wdata
    input  bool[DATA_WIDTH / 8]   s_axi_control_wstrb
    input  bool                   s_axi_control_wvalid
    output bool                   s_axi_control_wready  = ctrl.wready
    output bool[2]                s_axi_control_bresp   = ctrl.bresp
    output bool                   s_axi_control_bvalid  = ctrl.bvalid
    input  bool                   s_axi_control_bready
    input  int#(FROM: 0, TO: ATO) s_axi_control_araddr
    input  bool                   s_axi_control_arvalid
    output bool                   s_axi_control_arready = ctrl.arready
    output bool[DATA_WIDTH]       s_axi_control_rdata   = ctrl.rdata
    output bool[2]                s_axi_control_rresp   = ctrl.rresp
    output bool                   s_axi_control_rvalid  = ctrl.rvalid
    input  bool                   s_axi_control_rready
    ctrl.awaddr  = s_axi_control_awaddr
    ctrl.awvalid = s_axi_control_awvalid
    ctrl.wdata   = s_axi_control_wdata
    ctrl.wstrb   = s_axi_control_wstrb
    ctrl.wvalid  = s_axi_control_wvalid
    ctrl.bready  = s_axi_control_bready
    ctrl.araddr  = s_axi_control_araddr
    ctrl.arvalid = s_axi_control_arvalid
    ctrl.rready  = s_axi_control_rready
    
    output state bool[DATA_WIDTH] outstream_tdata
    output state bool             outstream_tvalid
    input  bool                   outstream_tready

    state bool[32][500] writes_shift_reg

    when s_axi_control_awvalid & s_axi_control_awready {
        bool[32] new_bits = UIntToBits(s_axi_control_awaddr)

        for int i in 1..500 {
            writes_shift_reg[i] = writes_shift_reg[i-1]
        }
        writes_shift_reg[0] = new_bits
    }
    

    // Actual logic
    when ctrl.start {
        int a = BitsToUInt(ctrl.input_regs[0])
        int b = BitsToUInt(ctrl.input_regs[1])

        int c = (a + b) % pow2#(E: 32)

        //wait_count = a

        
        ctrl.finish(writes_shift_reg)

        outstream_tvalid = true
        outstream_tdata = UIntToBits(c)
    }

    when outstream_tready & outstream_tvalid {
        outstream_tvalid = false
    }

    when !aresetn {
        outstream_tvalid = false 
        //bits_to_transmit = Repeat(true)
    }
}


module combined_axi_ctrl_plus_reader {
    domain aclk
    input bool aresetn

    gen int ADDR_WIDTH = 12
    gen int ATO = pow2#(E: ADDR_WIDTH)
    gen int MTO = pow2#(E: 64)
    gen int AXI_WIDTH = 32

    axi_ctrl_slave #(NUM_INPUT_REGS: 4, NUM_OUTPUT_REGS: 1, ADDR_WIDTH) ctrl
    ctrl.aresetn = aresetn

    // Export AXI4-Lite interface
    input  int#(FROM: 0, TO: ATO) s_axi_control_awaddr
    input  bool                   s_axi_control_awvalid
    output bool                   s_axi_control_awready = ctrl.awready
    input  bool[AXI_WIDTH]        s_axi_control_wdata
    input  bool[AXI_WIDTH / 8]    s_axi_control_wstrb
    input  bool                   s_axi_control_wvalid
    output bool                   s_axi_control_wready  = ctrl.wready
    output bool[2]                s_axi_control_bresp   = ctrl.bresp
    output bool                   s_axi_control_bvalid  = ctrl.bvalid
    input  bool                   s_axi_control_bready
    input  int#(FROM: 0, TO: ATO) s_axi_control_araddr
    input  bool                   s_axi_control_arvalid
    output bool                   s_axi_control_arready = ctrl.arready
    output bool[AXI_WIDTH]        s_axi_control_rdata   = ctrl.rdata
    output bool[2]                s_axi_control_rresp   = ctrl.rresp
    output bool                   s_axi_control_rvalid  = ctrl.rvalid
    input  bool                   s_axi_control_rready
    ctrl.awaddr  =                s_axi_control_awaddr
    ctrl.awvalid =                s_axi_control_awvalid
    ctrl.wdata   =                s_axi_control_wdata
    ctrl.wstrb   =                s_axi_control_wstrb
    ctrl.wvalid  =                s_axi_control_wvalid
    ctrl.bready  =                s_axi_control_bready
    ctrl.araddr  =                s_axi_control_araddr
    ctrl.arvalid =                s_axi_control_arvalid
    ctrl.rready  =                s_axi_control_rready

    axi_memory_reader#(T: type int#(FROM: 0, TO: pow2#(E: 32))) reader
    reader.aresetn = aresetn

    axi_memory_writer_tie_off writer
    writer.aresetn = aresetn

    output bool                     m_axi_awvalid = writer.awvalid
    input  bool                     m_axi_awready
    output int#(FROM: 0, TO: MTO)   m_axi_awaddr = writer.awaddr
    output int#(FROM: 0, TO: 256)   m_axi_awlen = writer.awlen
    output int#(FROM: 0, TO: 8)     m_axi_awsize  = writer.awsize
    output bool[2]                  m_axi_awburst = writer.awburst
    output bool[3]                  m_axi_awprot = writer.awprot
    output bool[4]                  m_axi_awcache = writer.awcache
    output int#(FROM: 0, TO: 16)    m_axi_awqos = writer.awqos
    output bool                     m_axi_awlock = writer.awlock
    output int#(FROM: 0, TO: 16)    m_axi_awregion = writer.awregion
    output bool                     m_axi_wvalid = writer.wvalid
    input  bool                     m_axi_wready
    output bool[AXI_WIDTH]          m_axi_wdata = writer.wdata
    output bool[AXI_WIDTH / 8]      m_axi_wstrb = writer.wstrb
    output bool                     m_axi_wlast = writer.wlast
    input  bool                     m_axi_bvalid
    output bool                     m_axi_bready = writer.bready
    input  bool[2]                  m_axi_bresp
    writer.awready =                m_axi_awready
    writer.wready =                 m_axi_wready
    writer.bvalid =                 m_axi_bvalid
    writer.bresp =                  m_axi_bresp
    output bool                     m_axi_arvalid = reader.arvalid
    input  bool                     m_axi_arready
    output int#(FROM: 0, TO: MTO)   m_axi_araddr = reader.araddr
    output int#(FROM: 0, TO: 256)   m_axi_arlen = reader.arlen
    output int#(FROM: 0, TO: 8)     m_axi_arsize  = reader.arsize
    output bool[2]                  m_axi_arburst = reader.arburst
    output bool[3]                  m_axi_arprot = reader.arprot
    output bool[4]                  m_axi_arcache = reader.arcache
    output int#(FROM: 0, TO: 16)    m_axi_arqos = reader.arqos
    output bool                     m_axi_arlock = reader.arlock
    output int#(FROM: 0, TO: 16)    m_axi_arregion = reader.arregion
    input  bool                     m_axi_rvalid
    output bool                     m_axi_rready = reader.rready
    input  bool[AXI_WIDTH]          m_axi_rdata
    input  bool[2]                  m_axi_rresp
    input  bool                     m_axi_rlast
    reader.arready =                m_axi_arready
    reader.rvalid =                 m_axi_rvalid
    reader.rdata =                  m_axi_rdata
    reader.rresp =                  m_axi_rresp
    reader.rlast =                  m_axi_rlast

    /// Output axi
    output state bool[32]         outstream_tdata
    output state bool             outstream_tvalid
    input  bool                   outstream_tready

    // Actual logic

    gen int STM_IDLE  = 0
    gen int STM_GET_A = 1
    gen int STM_GET_B = 2

    state int addr_state
    state int data_state

    when addr_state == STM_GET_A {
        bool[64] addr_a_bits
        addr_a_bits[:32] = ctrl.input_regs[0]
        addr_a_bits[32:] = ctrl.input_regs[1]
        when reader.request(BitsToUInt(addr_a_bits)) {
            addr_state = STM_GET_B
        }
    } else when addr_state == STM_GET_B {
        bool[64] addr_b_bits
        addr_b_bits[:32] = ctrl.input_regs[2]
        addr_b_bits[32:] = ctrl.input_regs[3]
        when reader.request(BitsToUInt(addr_b_bits)) {
            addr_state = STM_IDLE
        }
    }

    state int stored_a
    when data_state == STM_GET_A {
        bool success, int data = reader.read()
        when success {
            stored_a = data
            data_state = STM_GET_B
        }
    } else when data_state == STM_GET_B {
        bool success, int b = reader.read()
        when success {
            int c = (stored_a + b) % pow2#(E: 32)
            bool[32] c_as_bits = UIntToBits(c)
            ctrl.finish([c_as_bits])
            data_state = STM_IDLE

            outstream_tdata = c_as_bits
            outstream_tvalid = true
        }
    }

    when outstream_tvalid & outstream_tready {
        outstream_tvalid = false
    }

    when ctrl.start {
        addr_state = STM_GET_A
        data_state = STM_GET_A
    }

    when !aresetn {
        addr_state = STM_IDLE
        data_state = STM_IDLE
        outstream_tvalid = false
    }
}



module combined_axi_ctrl_reader_writer {
    domain aclk
    input bool aresetn

    gen int ADDR_WIDTH = 12
    gen int ATO = pow2#(E: ADDR_WIDTH)
    gen int MTO = pow2#(E: 64)
    gen int AXI_WIDTH = 32

    gen int NUM_VALUES = 8

    axi_ctrl_slave #(NUM_INPUT_REGS: 8, NUM_OUTPUT_REGS: 1, ADDR_WIDTH) ctrl
    ctrl.aresetn = aresetn

    // Export AXI4-Lite interface
    input  int#(FROM: 0, TO: ATO) s_axi_control_awaddr
    input  bool                   s_axi_control_awvalid
    output bool                   s_axi_control_awready = ctrl.awready
    input  bool[AXI_WIDTH]        s_axi_control_wdata
    input  bool[AXI_WIDTH / 8]    s_axi_control_wstrb
    input  bool                   s_axi_control_wvalid
    output bool                   s_axi_control_wready  = ctrl.wready
    output bool[2]                s_axi_control_bresp   = ctrl.bresp
    output bool                   s_axi_control_bvalid  = ctrl.bvalid
    input  bool                   s_axi_control_bready
    input  int#(FROM: 0, TO: ATO) s_axi_control_araddr
    input  bool                   s_axi_control_arvalid
    output bool                   s_axi_control_arready = ctrl.arready
    output bool[AXI_WIDTH]        s_axi_control_rdata   = ctrl.rdata
    output bool[2]                s_axi_control_rresp   = ctrl.rresp
    output bool                   s_axi_control_rvalid  = ctrl.rvalid
    input  bool                   s_axi_control_rready
    ctrl.awaddr  =         s_axi_control_awaddr
    ctrl.awvalid =         s_axi_control_awvalid
    ctrl.wdata   =         s_axi_control_wdata
    ctrl.wstrb   =         s_axi_control_wstrb
    ctrl.wvalid  =         s_axi_control_wvalid
    ctrl.bready  =         s_axi_control_bready
    ctrl.araddr  =         s_axi_control_araddr
    ctrl.arvalid =         s_axi_control_arvalid
    ctrl.rready  =         s_axi_control_rready

    axi_memory_reader#(T: type int#(FROM: 0, TO: pow2#(E: 32))[NUM_VALUES]) reader
    reader.aresetn = aresetn

    axi_memory_writer#(T: type int#(FROM: 0, TO: pow2#(E: 32))[NUM_VALUES]) writer
    writer.aresetn = aresetn

    output bool                     m_axi_awvalid = writer.awvalid
    input  bool                     m_axi_awready
    output int#(FROM: 0, TO: MTO)   m_axi_awaddr = writer.awaddr
    output int#(FROM: 0, TO: 256)   m_axi_awlen = writer.awlen
    output int#(FROM: 0, TO: 8)     m_axi_awsize  = writer.awsize
    output bool[2]                  m_axi_awburst = writer.awburst
    output bool[3]                  m_axi_awprot = writer.awprot
    output bool[4]                  m_axi_awcache = writer.awcache
    output int#(FROM: 0, TO: 16)    m_axi_awqos = writer.awqos
    output bool                     m_axi_awlock = writer.awlock
    output int#(FROM: 0, TO: 16)    m_axi_awregion = writer.awregion
    output bool                     m_axi_wvalid = writer.wvalid
    input  bool                     m_axi_wready
    output bool[AXI_WIDTH]          m_axi_wdata = writer.wdata
    output bool[AXI_WIDTH / 8]      m_axi_wstrb = writer.wstrb
    output bool                     m_axi_wlast = writer.wlast
    input  bool                     m_axi_bvalid
    output bool                     m_axi_bready = writer.bready
    input  bool[2]                  m_axi_bresp
    writer.awready =                m_axi_awready
    writer.wready =                 m_axi_wready
    writer.bvalid =                 m_axi_bvalid
    writer.bresp =                  m_axi_bresp
    output bool                     m_axi_arvalid = reader.arvalid
    input  bool                     m_axi_arready
    output int#(FROM: 0, TO: MTO)   m_axi_araddr = reader.araddr
    output int#(FROM: 0, TO: 256)   m_axi_arlen = reader.arlen
    output int#(FROM: 0, TO: 8)     m_axi_arsize  = reader.arsize
    output bool[2]                  m_axi_arburst = reader.arburst
    output bool[3]                  m_axi_arprot = reader.arprot
    output bool[4]                  m_axi_arcache = reader.arcache
    output int#(FROM: 0, TO: 16)    m_axi_arqos = reader.arqos
    output bool                     m_axi_arlock = reader.arlock
    output int#(FROM: 0, TO: 16)    m_axi_arregion = reader.arregion
    input  bool                     m_axi_rvalid
    output bool                     m_axi_rready = reader.rready
    input  bool[AXI_WIDTH]          m_axi_rdata
    input  bool[2]                  m_axi_rresp
    input  bool                     m_axi_rlast
    reader.arready =                m_axi_arready
    reader.rvalid =                 m_axi_rvalid
    reader.rdata =                  m_axi_rdata
    reader.rresp =                  m_axi_rresp
    reader.rlast =                  m_axi_rlast

    // Actual logic

    gen int STM_IDLE  = 0
    gen int STM_GET_A = 1
    gen int STM_GET_B = 2
    gen int STM_WRITE_C = 3
    gen int STM_WRITE_D = 4
    gen int STM_WAIT_FOR_FINISH = 5

    state int addr_state
    state int data_state


    bool[64] addr_a_bits
    addr_a_bits[:32] = ctrl.input_regs[0]
    addr_a_bits[32:] = ctrl.input_regs[1]
    bool[64] addr_b_bits
    addr_b_bits[:32] = ctrl.input_regs[2]
    addr_b_bits[32:] = ctrl.input_regs[3]
    bool[64] addr_c_bits
    addr_c_bits[:32] = ctrl.input_regs[4]
    addr_c_bits[32:] = ctrl.input_regs[5]
    bool[64] addr_d_bits
    addr_d_bits[:32] = ctrl.input_regs[6]
    addr_d_bits[32:] = ctrl.input_regs[7]

    when addr_state == STM_GET_A {
        when reader.request(BitsToUInt(addr_a_bits)) {
            addr_state = STM_GET_B
        }
    } else when addr_state == STM_GET_B {
        when reader.request(BitsToUInt(addr_b_bits)) {
            addr_state = STM_IDLE
        }
    }

    state int[NUM_VALUES] stored_a
    state int[NUM_VALUES] stored_b
    int[NUM_VALUES] c
    int[NUM_VALUES] d
    for int i in 0..NUM_VALUES {
        c[i] = (stored_a[i] + stored_b[i]) % pow2#(E: 32)
        d[i] = (stored_a[i] * stored_b[i]) % pow2#(E: 32)
    }
    when data_state == STM_GET_A {
        bool success, int[NUM_VALUES] data = reader.read()
        when success {
            stored_a = data
            data_state = STM_GET_B
        }
    } else when data_state == STM_GET_B {
        bool success, int[NUM_VALUES] data = reader.read()
        when success {
            stored_b = data
            data_state = STM_WRITE_C
        }
    } else when data_state == STM_WRITE_C {
        when writer.write(BitsToUInt(addr_c_bits), c) {
            data_state = STM_WRITE_D
        }
    } else when data_state == STM_WRITE_D {
        when writer.write(BitsToUInt(addr_d_bits), d) {
            data_state = STM_WAIT_FOR_FINISH
        }
    } else when data_state == STM_WAIT_FOR_FINISH {
        when !writer.has_outstanding_writes {
            data_state = STM_IDLE
            ctrl.finish([32'hDEADBEEF])
        }
    }

    when ctrl.start {
        addr_state = STM_GET_A
        data_state = STM_GET_A
    }

    when !aresetn {
        addr_state = STM_IDLE
        data_state = STM_IDLE
    }
}


module benchmark_burst_read#(int AXI_WIDTH) {
    domain aclk
    input bool aresetn

    gen int CTRL_AXI_WIDTH = 32
    gen int ADDR_WIDTH = 12
    gen int ATO = pow2#(E: ADDR_WIDTH)
    gen int MTO = pow2#(E: 64)

    gen int NUM_ELEMS = AXI_WIDTH / 32

    axi_ctrl_slave #(NUM_INPUT_REGS: 3, NUM_OUTPUT_REGS: 2, ADDR_WIDTH, AXI_WIDTH: CTRL_AXI_WIDTH) ctrl
    ctrl.aresetn = aresetn

    // Export AXI4-Lite interface
    input  int#(FROM: 0, TO: ATO)   s_axi_control_awaddr
    input  bool                     s_axi_control_awvalid
    output bool                     s_axi_control_awready = ctrl.awready
    input  bool[CTRL_AXI_WIDTH]     s_axi_control_wdata
    input  bool[CTRL_AXI_WIDTH / 8] s_axi_control_wstrb
    input  bool                     s_axi_control_wvalid
    output bool                     s_axi_control_wready  = ctrl.wready
    output bool[2]                  s_axi_control_bresp   = ctrl.bresp
    output bool                     s_axi_control_bvalid  = ctrl.bvalid
    input  bool                     s_axi_control_bready
    input  int#(FROM: 0, TO: ATO)   s_axi_control_araddr
    input  bool                     s_axi_control_arvalid
    output bool                     s_axi_control_arready = ctrl.arready
    output bool[CTRL_AXI_WIDTH]     s_axi_control_rdata   = ctrl.rdata
    output bool[2]                  s_axi_control_rresp   = ctrl.rresp
    output bool                     s_axi_control_rvalid  = ctrl.rvalid
    input  bool                     s_axi_control_rready
    ctrl.awaddr  =         s_axi_control_awaddr
    ctrl.awvalid =         s_axi_control_awvalid
    ctrl.wdata   =         s_axi_control_wdata
    ctrl.wstrb   =         s_axi_control_wstrb
    ctrl.wvalid  =         s_axi_control_wvalid
    ctrl.bready  =         s_axi_control_bready
    ctrl.araddr  =         s_axi_control_araddr
    ctrl.arvalid =         s_axi_control_arvalid
    ctrl.rready  =         s_axi_control_rready

    axi_realigning_burst_reader#(T: type bool[32][NUM_ELEMS], AXI_WIDTH, ADDR_ALIGN: 4, COUNT_TO: pow2#(E: 32), ATO: pow2#(E: 64)) reader
    reader.aresetn = aresetn

    axi_memory_writer_tie_off writer
    writer.aresetn = aresetn

    output bool                     m_axi_awvalid = writer.awvalid
    input  bool                     m_axi_awready
    output int#(FROM: 0, TO: MTO)   m_axi_awaddr = writer.awaddr
    output int#(FROM: 0, TO: 256)   m_axi_awlen = writer.awlen
    output int#(FROM: 0, TO: 8)     m_axi_awsize  = writer.awsize
    output bool[2]                  m_axi_awburst = writer.awburst
    output bool[3]                  m_axi_awprot = writer.awprot
    output bool[4]                  m_axi_awcache = writer.awcache
    output int#(FROM: 0, TO: 16)    m_axi_awqos = writer.awqos
    output bool                     m_axi_awlock = writer.awlock
    output int#(FROM: 0, TO: 16)    m_axi_awregion = writer.awregion
    output bool                     m_axi_wvalid = writer.wvalid
    input  bool                     m_axi_wready
    output bool[AXI_WIDTH]          m_axi_wdata = writer.wdata
    output bool[AXI_WIDTH / 8]      m_axi_wstrb = writer.wstrb
    output bool                     m_axi_wlast = writer.wlast
    input  bool                     m_axi_bvalid
    output bool                     m_axi_bready = writer.bready
    input  bool[2]                  m_axi_bresp
    writer.awready =                m_axi_awready
    writer.wready =                 m_axi_wready
    writer.bvalid =                 m_axi_bvalid
    writer.bresp =                  m_axi_bresp
    output bool                     m_axi_arvalid = reader.arvalid
    input  bool                     m_axi_arready
    output int#(FROM: 0, TO: MTO)   m_axi_araddr = reader.araddr
    output int#(FROM: 0, TO: 256)   m_axi_arlen = reader.arlen
    output int#(FROM: 0, TO: 8)     m_axi_arsize  = reader.arsize
    output bool[2]                  m_axi_arburst = reader.arburst
    output bool[3]                  m_axi_arprot = reader.arprot
    output bool[4]                  m_axi_arcache = reader.arcache
    output int#(FROM: 0, TO: 16)    m_axi_arqos = reader.arqos
    output bool                     m_axi_arlock = reader.arlock
    output int#(FROM: 0, TO: 16)    m_axi_arregion = reader.arregion
    input  bool                     m_axi_rvalid
    output bool                     m_axi_rready = reader.rready
    input  bool[AXI_WIDTH]          m_axi_rdata
    input  bool[2]                  m_axi_rresp
    input  bool                     m_axi_rlast
    reader.arready =                m_axi_arready
    reader.rvalid =                 m_axi_rvalid
    reader.rdata =                  m_axi_rdata
    reader.rresp =                  m_axi_rresp
    reader.rlast =                  m_axi_rlast


    bool[64] addr_a_bits
    addr_a_bits[:32] = ctrl.input_regs[0]
    addr_a_bits[32:] = ctrl.input_regs[1]

    int start_addr = BitsToUInt(addr_a_bits)
    int num_to_transfer = unsafe_int_cast#(FROM: 1, TO: pow2#(E: 32))(BitsToUInt(ctrl.input_regs[2]))

    state bool running
    state int num_cycles_running
    state bool[32] hash
    when ctrl.start {
        reader.request_new_burst(start_addr, num_to_transfer)
        running = true
        num_cycles_running = 0
    }

    when running {
        num_cycles_running = (num_cycles_running + 1) % pow2#(E: 32)
    }

    reader.is_ready_to_receive_lots_of_data = true
    when reader.value_valid: bool[32][NUM_ELEMS] value, bool last {
        bool[32] new_hash_contrib
        for int i in 0..32 {
            new_hash_contrib[i] = ^(value[:][i])
        }
        bool[32] new_hash = hash ^ new_hash_contrib
        when last {
            running = false
            ctrl.finish([UIntToBits(num_cycles_running), new_hash])
        }
        hash = new_hash
    }

    when !aresetn {
        running = false
        num_cycles_running = 0
        hash = 32'h00000000
    }
}

module all_benchmarks {
    benchmark_burst_read#(AXI_WIDTH: 32) burst32
    benchmark_burst_read#(AXI_WIDTH: 64) burst64
    benchmark_burst_read#(AXI_WIDTH: 128) burst128
    benchmark_burst_read#(AXI_WIDTH: 256) burst256
    benchmark_burst_read#(AXI_WIDTH: 512) burst512
}
